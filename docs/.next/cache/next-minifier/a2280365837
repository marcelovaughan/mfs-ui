{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{\"/BS6\":function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return l}));var t=o(\"z3IF\"),r=o(\"mXGw\"),i=o.n(r),a=o(\"oNR1\"),s=o(\"USb2\"),c=o(\"O8uh\"),p=i.a.createElement,m=i.a.forwardRef((function(n,e){return p(s.a,Object(t.a)({ref:e,to:\"/getting-started/installation/\"},n))})),d=p(a.a,null,p(\"div\",null,p(c.a,{color:\"primary\",component:s.a,to:\"/\"},\"With prop forwarding\"),p(\"br\",null),p(c.a,{color:\"primary\",component:m},\"Without prop forwarding\")));function l(){return d}},\"/wNM\":function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return m}));var t=o(\"mXGw\"),r=o.n(t),i=o(\"l/nz\"),a=o(\"Pw6v\"),s=r.a.createElement,c=function(n){return s(a.a,n)};c.muiName=\"Icon\";var p=s(\"div\",null,s(i.a,null,s(a.a,null,\"alarm\")),s(i.a,null,s(c,null,\"alarm\")));function m(){return p}},\"3uJ1\":function(n,e,o){\"use strict\";var t=o(\"z3IF\"),r=o(\"2Fjn\"),i=o(\"mXGw\"),a=o(\"PDtE\"),s=o(\"XpU0\"),c=o(\"Oy88\"),p=o(\"k+Qe\"),m=i.createElement,d=i.forwardRef((function(n,e){var o=n.children,s=n.classes,d=n.className,l=n.disableTypography,u=void 0!==l&&l,f=n.inset,h=void 0!==f&&f,w=n.primary,y=n.primaryTypographyProps,g=n.secondary,L=n.secondaryTypographyProps,I=Object(r.a)(n,[\"children\",\"classes\",\"className\",\"disableTypography\",\"inset\",\"primary\",\"primaryTypographyProps\",\"secondary\",\"secondaryTypographyProps\"]),v=i.useContext(p.a).dense,R=null!=w?w:o;null==R||R.type===c.a||u||(R=m(c.a,Object(t.a)({variant:v?\"body2\":\"body1\",className:s.primary,component:\"span\",display:\"block\"},y),R));var b=g;return null==b||b.type===c.a||u||(b=m(c.a,Object(t.a)({variant:\"body2\",className:s.secondary,color:\"textSecondary\",display:\"block\"},L),b)),m(\"div\",Object(t.a)({className:Object(a.a)(s.root,d,v&&s.dense,h&&s.inset,R&&b&&s.multiline),ref:e},I),R,b)}));e.a=Object(s.default)({root:{flex:\"1 1 auto\",minWidth:0,marginTop:4,marginBottom:4},multiline:{marginTop:6,marginBottom:6},dense:{},inset:{paddingLeft:56},primary:{},secondary:{}},{name:\"MuiListItemText\"})(d)},\"4fGY\":function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return R}));var t=o(\"z3IF\"),r=o(\"mXGw\"),i=o.n(r),a=o(\"yZEQ\"),s=o(\"AgvC\"),c=o(\"WSie\"),p=o(\"VPks\"),m=o(\"vR+x\"),d=o(\"3uJ1\"),l=o(\"FAXT\"),u=o(\"czfG\"),f=o(\"MIXp\"),h=o(\"Oy88\"),w=o(\"oNR1\"),y=o(\"USb2\"),g=i.a.createElement;function L(n){var e=n.icon,o=n.primary,r=n.to,a=i.a.useMemo((function(){return i.a.forwardRef((function(n,e){return g(y.a,Object(t.a)({to:r,ref:e},n))}))}),[r]);return g(\"li\",null,g(c.a,{button:!0,component:a},e?g(m.a,null,e):null,g(d.a,{primary:o})))}var I=Object(a.a)({root:{width:360}}),v=g(p.a,{elevation:0},g(s.a,{\"aria-label\":\"main mailbox folders\"},g(L,{to:\"/inbox\",primary:\"Inbox\",icon:g(u.a,null)}),g(L,{to:\"/drafts\",primary:\"Drafts\",icon:g(f.a,null)})),g(l.a,null),g(s.a,{\"aria-label\":\"secondary mailbox folders\"},g(L,{to:\"/trash\",primary:\"Trash\"}),g(L,{to:\"/spam\",primary:\"Spam\"})));function R(){var n=I();return g(w.a,{initialEntries:[\"/drafts\"],initialIndex:0},g(\"div\",{className:n.root},g(w.b,null,(function(n){var e=n.location;return g(h.a,{gutterBottom:!0},\"Current route: \",e.pathname)})),v))}},\"5YrX\":function(n,e){n.exports='# Composici\\xf3n\\n\\n<p class=\"description\">Material-UI intenta hacer que la composici\\xf3n sea lo m\\xe1s f\\xe1cil como sea posible.</p>\\n\\n## Envolviendo componentes\\n\\nPara proporcionar la m\\xe1xima flexibilidad y rendimiento, necesitamos una forma de conocer la naturaleza de los elementos secundarios que recibe un componente. Para resolver este problema, etiquetamos algunos de los componentes con una propiedad est\\xe1tica `muiName` cuando es necesario.\\n\\nYou may, however, need to wrap a component in order to enhance it, which can conflict with the `muiName` solution. If you wrap a component, verify if that component has this static property set.\\n\\nIf you encounter this issue, you need to use the same tag for your wrapping component that is used with the wrapped component. In addition, you should forward the properties, as the parent component may need to control the wrapped components props.\\n\\nLet\\'s see an example:\\n\\n```jsx\\nconst WrappedIcon = props => <Icon {...props} />;\\nWrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## Component prop\\n\\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\\n\\n### How does it work?\\n\\nThe custom component will be rendered by Material-UI like this:\\n\\n```js\\nreturn React.createElement(props.component, props)\\n```\\n\\nFor example, by default a `List` component will render a `<ul>` element. This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. But it also **comes with a small caveat!**\\n\\n### Caveat with inlining\\n\\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. For instance, if you want to create a custom `ListItem` that acts as a link, you could do the following:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = props => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f However, since we are using an inline function to change the rendered component, React will unmount the link every time `ListItemLink` is rendered. Not only will React update the DOM unnecessarily, the ripple effect of the `ListItem` will also not work correctly.\\n\\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let\\'s change the `ListItemLink` component so `CustomLink` always reference the same component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Caveat with prop forwarding\\n\\nYou can take advantage of the prop forwarding to simplify the code. In this example, we don\\'t create any intermediary component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\\n\\n### With TypeScript\\n\\nYou can find the details in the [TypeScript guide](/guides/typescript/#usage-of-component-prop).\\n\\n## Routing libraries\\n\\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\\n\\n### Button (Bot\\xf3n)\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### List\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## Caveat with refs\\n\\nThis section covers caveats when using a custom component as `children` or for the `component` prop.\\n\\nSome of the components need access to the DOM node. This was previously possible by using `ReactDOM.findDOMNode`. This function is deprecated in favor of `ref` and ref forwarding. However, only the following component types can be given a `ref`:\\n\\n- Any Material-UI component\\n- class components i.e. `React.Component` or `React.PureComponent`\\n- DOM (or host) components e.g. `div` or `button`\\n- [React.forwardRef components](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [React.lazy components](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [React.memo components](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\nIf you don\\'t use one of the above types when using your components in conjunction with Material-UI, you might see a warning from React in your console similar to:\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\nBe aware that you will still get this warning for `lazy` and `memo` components if their wrapped component can\\'t hold a ref.\\n\\nIn some instances an additional warning is issued to help with debugging, similar to:\\n\\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\\n\\nOnly the two most common use cases are covered. For more information see [this section in the official React docs](https://reactjs.org/docs/forwarding-refs.html).\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\nTo find out if the Material-UI component you\\'re using has this requirement, check out the the props API documentation for that component. If you need to forward refs the description will link to this section.\\n\\n### Caveat with StrictMode\\n\\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```'},\"61vW\":function(n,e){n.exports=\"import React from 'react';\\nimport { MemoryRouter as Router } from 'react-router';\\nimport {\\n  Link as RouterLink,\\n  LinkProps as RouterLinkProps,\\n} from 'react-router-dom';\\nimport Button from '@material-ui/core/Button';\\nimport { Omit } from '@material-ui/types';\\n\\nconst LinkBehavior = React.forwardRef<any, Omit<RouterLinkProps, 'to'>>(\\n  (props, ref) => (\\n    <RouterLink ref={ref} to=\\\"/getting-started/installation/\\\" {...props} />\\n  ),\\n);\\n\\nexport default function ButtonRouter() {\\n  return (\\n    <Router>\\n      <div>\\n        <Button color=\\\"primary\\\" component={RouterLink} to=\\\"/\\\">\\n          With prop forwarding\\n        </Button>\\n        <br />\\n        <Button color=\\\"primary\\\" component={LinkBehavior}>\\n          Without prop forwarding\\n        </Button>\\n      </div>\\n    </Router>\\n  );\\n}\\n\"},\"6XOy\":function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return l}));var t=o(\"z3IF\"),r=o(\"mXGw\"),i=o.n(r),a=o(\"oNR1\"),s=o(\"USb2\"),c=o(\"O8uh\"),p=i.a.createElement,m=i.a.forwardRef((function(n,e){return p(s.a,Object(t.a)({ref:e,to:\"/getting-started/installation/\"},n))})),d=p(a.a,null,p(\"div\",null,p(c.a,{color:\"primary\",component:s.a,to:\"/\"},\"With prop forwarding\"),p(\"br\",null),p(c.a,{color:\"primary\",component:m},\"Without prop forwarding\")));function l(){return d}},\"6jai\":function(n,e){n.exports=\"import React from 'react';\\nimport IconButton from '@material-ui/core/IconButton';\\nimport Icon from '@material-ui/core/Icon';\\n\\nconst WrappedIcon = (props) => <Icon {...props} />;\\nWrappedIcon.muiName = 'Icon';\\n\\nexport default function Composition() {\\n  return (\\n    <div>\\n      <IconButton>\\n        <Icon>alarm</Icon>\\n      </IconButton>\\n      <IconButton>\\n        <WrappedIcon>alarm</WrappedIcon>\\n      </IconButton>\\n    </div>\\n  );\\n}\\n\"},\"9Dhp\":function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return m}));var t=o(\"mXGw\"),r=o.n(t),i=o(\"l/nz\"),a=o(\"Pw6v\"),s=r.a.createElement,c=function(n){return s(a.a,n)};c.muiName=\"Icon\";var p=s(\"div\",null,s(i.a,null,s(a.a,null,\"alarm\")),s(i.a,null,s(c,null,\"alarm\")));function m(){return p}},\"BP5+\":function(n,e){n.exports='# Composi\\xe7\\xe3o\\n\\n<p class=\"description\">Material-UI tenta tornar a composi\\xe7\\xe3o o mais f\\xe1cil poss\\xedvel.</p>\\n\\n## Encapsulando componentes\\n\\nPara fornecer o m\\xe1ximo de flexibilidade e desempenho, precisamos de uma maneira de conhecer a natureza dos elementos filhos que um componente recebe. Para resolver esse problema, identificamos alguns dos componentes com uma propriedade est\\xe1tica `muiName` quando necess\\xe1rio.\\n\\nVoc\\xea pode, no entanto, precisar encapsular um componente para melhor\\xe1-lo, que pode entrar em conflito com a solu\\xe7\\xe3o `muiName`. Se voc\\xea encapsular um componente, verifique se este tem um conjunto de propriedades est\\xe1ticas.\\n\\nSe voc\\xea encontrar esse problema, precisar\\xe1 usar a mesma propriedade `muiName` do componente que ser\\xe1 encapsulado no seu componente encapsulado. Al\\xe9m disso, voc\\xea deve encaminhar as propriedades, j\\xe1 que o componente pai pode precisar controlar as propriedades do componente encapsulado.\\n\\nVamos ver um exemplo:\\n\\n```jsx\\nconst WrappedIcon = props => <Icon {...props} />;\\nWrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## Propriedade Componente\\n\\nMaterial-UI permite que voc\\xea altere o elemento raiz que ser\\xe1 renderizado por meio de uma propriedade chamada `component`.\\n\\n### Como \\xe9 que funciona?\\n\\nO componente customizado ser\\xe1 renderizado pelo Material-UI desta forma:\\n\\n```js\\nreturn React.createElement(props.component, props)\\n```\\n\\nPor exemplo, por padr\\xe3o um componente `List` ir\\xe1 renderizar um elemento `<ul>`. Isso pode ser alterado passando um [componente React](https://reactjs.org/docs/components-and-props.html#function-and-class-components) para a propriedade `component`. O exemplo a seguir ir\\xe1 renderizar o componente `List` como um elemento `<nav>` como raiz:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nEsse padr\\xe3o \\xe9 muito poderoso e permite uma grande flexibilidade, al\\xe9m de uma maneira de interoperar com outras bibliotecas, como a sua biblioteca de formul\\xe1rios ou roteamento favorita. Mas tamb\\xe9m **vem com uma pequena advert\\xeancia!**\\n\\n### Advert\\xeancia com o uso de fun\\xe7\\xf5es em linha\\n\\nUsando uma fun\\xe7\\xe3o em linha como um argumento para a propriedade `component` pode resultar em **desmontagem inesperada**, j\\xe1 que um novo componente \\xe9 passado cada vez que o React renderiza. Por exemplo, se voc\\xea quiser cria um `ListItem` customizado que atua como link, voc\\xea poderia fazer o seguinte:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = props => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f No entanto, como estamos usando uma fun\\xe7\\xe3o em linha para alterar o componente renderizado, o React desmontar\\xe1 o link toda vez que o `ListItemLink` \\xe9 renderizado. N\\xe3o s\\xf3 ir\\xe1 o React atualizar o DOM desnecessariamente, como o efeito cascata do `ListItem` tamb\\xe9m n\\xe3o funcionar\\xe1 corretamente.\\n\\nA solu\\xe7\\xe3o \\xe9 simples: **evite fun\\xe7\\xf5es em linha e passe um componente est\\xe1tico para a propriedade `component`**. Vamos mudar o componente `ListItemLink` para que `CustomLink` sempre referencie o mesmo componente:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Advert\\xeancia com o encaminhamento de propriedades\\n\\nVoc\\xea pode aproveitar o encaminhamento de propriedades para simplificar o c\\xf3digo. Neste exemplo, n\\xe3o criamos nenhum componente intermedi\\xe1rio:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f No entanto, esta estrat\\xe9gia sofre de uma limita\\xe7\\xe3o: colis\\xf5es de propriedade. O componente que fornece a propriedade `component` (por exemplo, ListItem) pode n\\xe3o encaminhar todas as propriedades (por exemplo) para o elemento raiz.\\n\\n### Usando TypeScript\\n\\nVoc\\xea pode encontrar os detalhes no [guia TypeScript](/guides/typescript/#usage-of-component-prop).\\n\\n## Bibliotecas de roteamento\\n\\nA integra\\xe7\\xe3o com bibliotecas de roteamento de terceiros \\xe9 resolvida com a propriedade `component`. O comportamento \\xe9 id\\xeantico \\xe0 descri\\xe7\\xe3o da propriedade acima. Aqui est\\xe3o algumas demonstra\\xe7\\xf5es com [react-router-dom](https://github.com/ReactTraining/react-router). Ele cobre os componentes Button, Link e List, voc\\xea deve ser capaz de aplicar a mesma estrat\\xe9gia com todos os componentes.\\n\\n### Button\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### List\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## Advert\\xeancia com refs\\n\\nEsta se\\xe7\\xe3o aborda advert\\xeancias ao usar um componente customizado como `children` ou para a propriedade `component`.\\n\\nAlguns dos componentes precisam acessar o n\\xf3 DOM. Anteriormente, isso era poss\\xedvel usando `ReactDOM.findDOMNode`. Esta fun\\xe7\\xe3o est\\xe1 obsoleta em favor da utiliza\\xe7\\xe3o de `ref` e encaminhamento de ref. No entanto, apenas os seguintes tipos de componentes podem receber um `ref`:\\n\\n- Qualquer componente do Material-UI\\n- componentes de classe, ou seja, `React.Component` ou `React.PureComponent`\\n- Componentes DOM (ou hospedeiro), por exemplo, `div` ou `button`\\n- [Componentes React.forwardRef](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [Componentes React.lazy](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [Componentes React.memo](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\nSe voc\\xea n\\xe3o usar um dos tipos acima ao usar seus componentes em conjunto com o Material-UI, poder\\xe1 ver um aviso do React no seu console semelhante a:\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\nEsteja ciente que voc\\xea ainda receber\\xe1 este aviso para componentes `lazy` ou `memo` se eles forem encapsulados por um componente que n\\xe3o cont\\xe9m ref.\\n\\nEm alguns casos, um aviso adicional \\xe9 emitido para ajudar na depura\\xe7\\xe3o, semelhante a:\\n\\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\\n\\nS\\xf3 as duas formas de utiliza\\xe7\\xe3o mais comuns s\\xe3o cobertas aqui. Para mais informa\\xe7\\xf5es, consulte [esta se\\xe7\\xe3o na documenta\\xe7\\xe3o oficial do React](https://reactjs.org/docs/forwarding-refs.html).\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\nPara descobrir se o componente de Material-UI que voc\\xea est\\xe1 usando tem esse requisito, verifique na documenta\\xe7\\xe3o de propriedades da API do componente. Se voc\\xea precisar encaminhar refs, a descri\\xe7\\xe3o ser\\xe1 vinculada a esta se\\xe7\\xe3o.\\n\\n### Advert\\xeancia com StrictMode\\n\\nSe voc\\xea usar componentes de classe para os casos descritos acima, ainda ver\\xe1 avisos em `React.StrictMode`. `ReactDOM.findDOMNode` \\xe9 usado internamente para compatibilidade com vers\\xf5es anteriores. Voc\\xea pode usar `React.forwardRef` e uma propriedade designada em seu componente de classe para encaminhar o `ref` para um componente DOM. Fazendo isso n\\xe3o deve acionar mais nenhum aviso relacionado \\xe0 deprecia\\xe7\\xe3o de uso de `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```'},F12Z:function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return R}));var t=o(\"z3IF\"),r=o(\"mXGw\"),i=o.n(r),a=o(\"yZEQ\"),s=o(\"AgvC\"),c=o(\"WSie\"),p=o(\"VPks\"),m=o(\"vR+x\"),d=o(\"3uJ1\"),l=o(\"FAXT\"),u=o(\"czfG\"),f=o(\"MIXp\"),h=o(\"Oy88\"),w=o(\"oNR1\"),y=o(\"USb2\"),g=i.a.createElement;function L(n){var e=n.icon,o=n.primary,r=n.to,a=i.a.useMemo((function(){return i.a.forwardRef((function(n,e){return g(y.a,Object(t.a)({to:r,ref:e},n))}))}),[r]);return g(\"li\",null,g(c.a,{button:!0,component:a},e?g(m.a,null,e):null,g(d.a,{primary:o})))}var I=Object(a.a)({root:{width:360}}),v=g(p.a,{elevation:0},g(s.a,{\"aria-label\":\"main mailbox folders\"},g(L,{to:\"/inbox\",primary:\"Inbox\",icon:g(u.a,null)}),g(L,{to:\"/drafts\",primary:\"Drafts\",icon:g(f.a,null)})),g(l.a,null),g(s.a,{\"aria-label\":\"secondary mailbox folders\"},g(L,{to:\"/trash\",primary:\"Trash\"}),g(L,{to:\"/spam\",primary:\"Spam\"})));function R(){var n=I();return g(w.a,{initialEntries:[\"/drafts\"],initialIndex:0},g(\"div\",{className:n.root},g(w.b,null,(function(n){var e=n.location;return g(h.a,{gutterBottom:!0},\"Current route: \",e.pathname)})),v))}},LDqK:function(n,e){n.exports='# crwdns95346:0crwdne95346:0\\n\\n<p class=\"description\">crwdns95348:0crwdne95348:0</p>\\n\\n## crwdns95350:0crwdne95350:0\\n\\ncrwdns95352:0crwdne95352:0 crwdns101252:0crwdne101252:0\\n\\ncrwdns95356:0crwdne95356:0 crwdns95358:0crwdne95358:0\\n\\ncrwdns95360:0crwdne95360:0 crwdns95362:0crwdne95362:0\\n\\ncrwdns95364:0crwdne95364:0\\n\\n```jsx\\ncrwdns95366:0{...props}crwdne95366:0\\n```\\n\\ncrwdns95368:0crwdne95368:0\\n\\n## crwdns101568:0crwdne101568:0\\n\\ncrwdns101570:0crwdne101570:0\\n\\n### crwdns95374:0crwdne95374:0\\n\\ncrwdns131514:0crwdne131514:0\\n\\n```js\\ncrwdns101572:0crwdne101572:0\\n```\\n\\ncrwdns95380:0crwdne95380:0 crwdns101574:0crwdne101574:0 crwdns101576:0crwdne101576:0\\n\\n```jsx\\ncrwdns101578:0crwdne101578:0\\n```\\n\\ncrwdns101580:0crwdne101580:0 crwdns95390:0crwdne95390:0\\n\\n### crwdns95392:0crwdne95392:0\\n\\ncrwdns101582:0crwdne101582:0 crwdns95396:0crwdne95396:0\\n\\n```jsx\\ncrwdns131516:0{ Link }crwdnd131516:0{ icon, primary, to }crwdnd131516:0{to}crwdnd131516:0{...props}crwdnd131516:0{CustomLink}crwdnd131516:0{icon}crwdnd131516:0{primary}crwdne131516:0\\n```\\n\\ncrwdns95400:0crwdne95400:0 crwdns95402:0crwdne95402:0\\n\\ncrwdns101586:0crwdne101586:0 crwdns131518:0crwdne131518:0\\n\\n```jsx\\ncrwdns131520:0{ Link }crwdnd131520:0{ icon, primary, to }crwdnd131520:0{ref}crwdnd131520:0{to}crwdnd131520:0{...linkProps}crwdnd131520:0[to]crwdnd131520:0{CustomLink}crwdnd131520:0{icon}crwdnd131520:0{primary}crwdne131520:0\\n```\\n\\n### crwdns101590:0crwdne101590:0\\n\\ncrwdns131522:0crwdne131522:0 crwdns131524:0crwdne131524:0\\n\\n```jsx\\ncrwdns95418:0{ Link }crwdnd95418:0{Link}crwdne95418:0\\n```\\n\\ncrwdns131526:0crwdne131526:0 crwdns131528:0crwdne131528:0\\n\\n### crwdns101598:0crwdne101598:0\\n\\ncrwdns131530:0crwdne131530:0\\n\\n## crwdns101602:0crwdne101602:0\\n\\ncrwdns131532:0crwdne131532:0 crwdns131534:0crwdne131534:0 crwdns131536:0crwdne131536:0 crwdns131538:0crwdne131538:0\\n\\n### crwdns101612:0crwdne101612:0\\n\\ncrwdns131540:0crwdne131540:0\\n\\n### crwdns101616:0crwdne101616:0\\n\\ncrwdns131542:0crwdne131542:0\\n\\n### crwdns101620:0crwdne101620:0\\n\\ncrwdns131544:0crwdne131544:0\\n\\n## crwdns101624:0crwdne101624:0\\n\\ncrwdns131546:0crwdne131546:0\\n\\ncrwdns131548:0crwdne131548:0 crwdns131550:0crwdne131550:0 crwdns131552:0crwdne131552:0 crwdns131554:0crwdne131554:0\\n\\n- crwdns95446:0crwdne95446:0\\n- crwdns95448:0crwdne95448:0\\n- crwdns95450:0crwdne95450:0\\n- [crwdns95454:0crwdne95454:0](crwdns95452:0crwdne95452:0)\\n- [crwdns95458:0crwdne95458:0](crwdns95456:0crwdne95456:0)\\n- [crwdns95462:0crwdne95462:0](crwdns95460:0crwdne95460:0)\\n\\ncrwdns131556:0crwdne131556:0\\n\\n> crwdns95466:0crwdne95466:0 crwdns95468:0crwdne95468:0 crwdns95470:0crwdne95470:0\\n\\ncrwdns131558:0crwdne131558:0\\n\\ncrwdns131560:0crwdne131560:0\\n\\n> crwdns95476:0crwdne95476:0 crwdns95478:0crwdne95478:0\\n\\ncrwdns131562:0crwdne131562:0 crwdns131564:0crwdne131564:0\\n\\n```diff\\ncrwdns131566:0{...props}crwdnd131566:0{...props}crwdnd131566:0{ref}crwdnd131566:0{MyButton}crwdne131566:0\\n```\\n\\n```diff\\ncrwdns131568:0{...props}crwdnd131568:0{...props}crwdnd131568:0{ref}crwdne131568:0\\n```\\n\\ncrwdns131570:0crwdne131570:0 crwdns131572:0crwdne131572:0\\n\\n### crwdns101650:0crwdne101650:0\\n\\ncrwdns131574:0crwdne131574:0 crwdns131576:0crwdne131576:0 crwdns131578:0crwdne131578:0 crwdns131580:0crwdne131580:0\\n\\n```diff\\ncrwdns95502:0{ props }crwdnd95502:0{ forwardedRef, ...props }crwdnd95502:0{...props}crwdnd95502:0{forwardedRef}crwdnd95502:0{...props}crwdnd95502:0{ref}crwdne95502:0\\n```'},MIXp:function(n,e,o){\"use strict\";var t=o(\"mXGw\"),r=o(\"vtGe\"),i=t.createElement;e.a=Object(r.a)(i(\"path\",{d:\"M21.99 8c0-.72-.37-1.35-.94-1.7L12 1 2.95 6.3C2.38 6.65 2 7.28 2 8v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zM12 13L3.74 7.84 12 3l8.26 4.84L12 13z\"}),\"Drafts\")},Oin9:function(n,e){n.exports='# Composition \\u7ec4\\u5408\\n\\n<p class=\"description\">Material-UI \\u8bd5\\u7740\\u8ba9\\u7ec4\\u5408\\u5c3d\\u53ef\\u80fd\\u7684\\u7b80\\u5355\\u3002</p>\\n\\n## \\u5c01\\u88c5\\u7ec4\\u4ef6\\n\\n\\u6211\\u4eec\\u9700\\u8981\\u4e00\\u79cd\\u4e86\\u89e3\\u7ec4\\u4ef6\\u63a5\\u6536\\u7684\\u5b50\\u5143\\u7d20\\u7684\\u672c\\u8d28\\u7684\\u65b9\\u5f0f\\uff0c\\u8fd9\\u6837\\u53ef\\u4ee5\\u5c3d\\u53ef\\u80fd\\u63d0\\u4f9b\\u6700\\u5927\\u7684\\u7075\\u6d3b\\u6027\\u548c\\u6700\\u597d\\u7684\\u6027\\u80fd\\u3002 To solve this problem we tag some of the components with a `muiName` static property when needed.\\n\\n\\u4f46\\u662f\\uff0c\\u60a8\\u4ecd\\u53ef\\u80fd\\u9700\\u8981\\u5c01\\u88c5\\u4e00\\u4e2a\\u7ec4\\u4ef6\\u4ee5\\u589e\\u5f3a\\u5b83\\u7684\\u529f\\u80fd\\uff0c\\u800c\\u8fd9\\u53ef\\u80fd\\u4e0e `muiName` \\u7684\\u89e3\\u51b3\\u65b9\\u6848\\u76f8\\u51b2\\u7a81\\u3002 If you wrap a component, verify if that component has this static property set.\\n\\n\\u5982\\u679c\\u60a8\\u9047\\u5230\\u6b64\\u95ee\\u9898\\uff0c\\u90a3\\u4e48\\u8bf7\\u4e3a\\u5c01\\u88c5\\u7ec4\\u4ef6\\u9644\\u52a0\\u4e0a\\u4e0e\\u88ab\\u5c01\\u88c5\\u7ec4\\u4ef6\\u4e00\\u6837\\u7684\\u6807\\u8bb0\\u3002 \\u53e6\\u5916\\uff0c\\u9274\\u4e8e\\u7236\\u7ec4\\u4ef6\\u53ef\\u80fd\\u9700\\u8981\\u5bf9\\u88ab\\u5c01\\u88c5\\u7684\\u7ec4\\u4ef6\\u5c5e\\u6027\\u52a0\\u4ee5\\u63a7\\u5236\\uff0c\\u60a8\\u5e94\\u8be5\\u5411\\u7236\\u7ec4\\u4ef6\\u4f20\\u9012\\u8fd9\\u4e9b\\u5c5e\\u6027\\u3002\\n\\n\\u8ba9\\u6211\\u4eec\\u6765\\u770b\\u4e00\\u4e2a\\u4f8b\\u5b50\\uff1a\\n\\n```jsx\\nconst WrappedIcon = props => <Icon {...props} />;\\nWrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## \\u7ec4\\u4ef6\\u5c5e\\u6027\\n\\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\\n\\n### \\u5b83\\u662f\\u5982\\u4f55\\u5de5\\u4f5c\\u7684\\u5462\\uff1f\\n\\nThe custom component will be rendered by Material-UI like this:\\n\\n```js\\nreturn React.createElement(props.component, props)\\n```\\n\\n\\u4f8b\\u5982\\uff0c\\u5728\\u9ed8\\u8ba4\\u60c5\\u51b5\\u4e0b\\uff0c`List` \\u7ec4\\u4ef6\\u4f1a\\u6e32\\u67d3 `<ul>` \\u5143\\u7d20\\u3002 This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. \\u4f46\\u5b83\\u4e5f**\\u5e26\\u6709\\u4e00\\u4e2a\\u5c0f\\u5c0f\\u7684\\u8b66\\u544a!**\\n\\n### \\u5f53\\u4e0e\\u5185\\u8054\\u51fd\\u6570\\u4e00\\u8d77\\u4f7f\\u7528\\u65f6\\u8981\\u6ce8\\u610f\\n\\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. \\u4f8b\\u5982\\uff0c\\u5982\\u679c\\u8981\\u521b\\u5efa\\u81ea\\u5b9a\\u4e49` ListItem `\\u4f5c\\u4e3a\\u94fe\\u63a5\\uff0c\\u60a8\\u53ef\\u4ee5\\u6267\\u884c\\u4ee5\\u4e0b\\u64cd\\u4f5c\\uff1a\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = props => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f\\u7136\\u800c\\uff0c\\u7531\\u4e8e\\u6211\\u4eec\\u4f7f\\u7528\\u5185\\u8054\\u51fd\\u6570\\u6765\\u66f4\\u6539\\u5448\\u73b0\\u7684\\u7ec4\\u4ef6\\uff0c\\u56e0\\u6b64\\uff0c\\u5728\\u6bcf\\u4e00\\u6b21` ListItemLink `\\u88ab\\u6e32\\u67d3\\u65f6\\uff0cReact\\u90fd\\u4f1a\\u5148\\u5c06\\u5b83\\u5378\\u8f7d\\u3002 \\u4e0d\\u53ea\\u662fReact\\u4f1a\\u66f4\\u65b0\\u90a3\\u4e9b\\u4e0d\\u5fc5\\u8981\\u7684DOM\\uff0c`ListItem` \\u7684\\u6d9f\\u6f2a\\u6548\\u5e94\\u4e5f\\u5c06\\u65e0\\u6cd5\\u6b63\\u5e38\\u5de5\\u4f5c\\u3002\\n\\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let\\'s change the `ListItemLink` component so `CustomLink` always reference the same component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Caveat with prop forwarding\\n\\nYou can take advantage of the prop forwarding to simplify the code. \\u5728\\u6b64\\u793a\\u4f8b\\u4e2d\\uff0c\\u6211\\u4eec\\u4e0d\\u521b\\u5efa\\u4efb\\u4f55\\u4e2d\\u95f4\\u7ec4\\u4ef6\\uff1a\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\\n\\n### \\u4f7f\\u7528 TypeScript\\n\\nYou can find the details in the [TypeScript guide](/guides/typescript/#usage-of-component-prop).\\n\\n## Routing libraries\\n\\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\\n\\n### Button\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### Lists\\uff08\\u5217\\u8868\\uff09\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## \\u4f7f\\u7528refs\\u65f6\\u8981\\u6ce8\\u610f\\n\\n\\u672c\\u8282\\u4ecb\\u7ecd\\u5c06\\u81ea\\u5b9a\\u4e49\\u7ec4\\u4ef6\\u7528\\u4f5c`\\u5b50\\u7ec4\\u4ef6`\\u6216`component`\\u5c5e\\u6027\\u7684\\u503c\\u65f6\\u7684\\u6ce8\\u610f\\u4e8b\\u9879\\u3002\\n\\n\\u67d0\\u4e9b\\u7ec4\\u4ef6\\u9700\\u8981\\u8bbf\\u95eeDOM\\u8282\\u70b9\\u3002 \\u4e4b\\u524d\\u63d0\\u5230\\uff0c\\u901a\\u8fc7\\u4f7f\\u7528` ReactDOM.findDOMNode ` \\u5c31\\u80fd\\u5b9e\\u73b0\\u3002 \\u8be5\\u65b9\\u6cd5\\u5df2\\u88ab\\u5e9f\\u5f03\\uff0c\\u4ee3\\u66ff\\u7684\\u662f\\u4f7f\\u7528` ref `\\u548c ref \\u8f6c\\u9012\\u3002 \\u7136\\u800c\\uff0c\\u53ea\\u6709\\u4e0b\\u5217\\u7ec4\\u4ef6\\u7c7b\\u578b\\u624d\\u53ef\\u83b7\\u5f97 `ref`\\uff1a\\n\\n- \\u4efb\\u4f55Material-UI\\u7ec4\\u4ef6\\n- \\u7c7b\\u7ec4\\u4ef6\\uff0c\\u5982 `React.Component` \\u6216 `React.PureComponent` \\u7b49\\n- DOM (\\u6216 host) \\u7ec4\\u4ef6\\uff0c\\u4f8b\\u5982 `div` \\u6216 `button`\\u7b49\\n- [React.forwardRef\\u7ec4\\u4ef6](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [React.lazy\\u7ec4\\u4ef6](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [React.memo\\u7ec4\\u4ef6](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\n\\u5982\\u679c\\u5728\\u5c06\\u7ec4\\u4ef6\\u4e0eMaterial-UI\\u7ed3\\u5408\\u4f7f\\u7528\\u65f6\\u672a\\u4f7f\\u7528\\u4e0a\\u8ff0\\u7c7b\\u578b\\u4e4b\\u4e00\\uff0c\\u5219\\u53ef\\u80fd\\u4f1a\\u5728\\u63a7\\u5236\\u53f0\\u4e2d\\u770b\\u5230\\u6765\\u81eaReact\\u7684\\u8b66\\u544a\\uff0c\\u7c7b\\u4f3c\\u4e8e\\uff1a\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\n\\u8bf7\\u6ce8\\u610f\\uff0c\\u5728\\u4f7f\\u7528 `lazy` \\u548c `memo` \\u7ec4\\u4ef6\\u65f6\\uff0c\\u5982\\u679c\\u88ab\\u5c01\\u88c5\\u7684\\u7ec4\\u4ef6\\u65e0\\u6cd5\\u6301\\u6709 ref\\uff0c\\u60a8\\u4ecd\\u7136\\u6709\\u53ef\\u80fd\\u6536\\u5230\\u8fd9\\u4e2a\\u8b66\\u544a\\u3002\\n\\nIn some instances an additional warning is issued to help with debugging, similar to:\\n\\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\\n\\nOnly the two most common use cases are covered. \\u66f4\\u591a\\u4fe1\\u606f\\u89c1[React\\u5b98\\u65b9\\u6587\\u6863\\u4e2d\\u7684\\u672c\\u7ae0\\u8282](https://reactjs.org/docs/forwarding-refs.html)\\u3002\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\n\\u8981\\u786e\\u5b9a\\u60a8\\u4f7f\\u7528\\u7684Material-UI\\u7ec4\\u4ef6\\u662f\\u5426\\u5177\\u6709\\u6b64\\u9700\\u6c42\\uff0c\\u8bf7\\u67e5\\u9605\\u8be5\\u7ec4\\u4ef6\\u7684props API\\u6587\\u6863\\u3002 \\u5982\\u679c\\u60a8\\u9700\\u8981\\u8f6c\\u9012 refs\\uff0c\\u63cf\\u8ff0\\u5c06\\u94fe\\u63a5\\u5230\\u6b64\\u90e8\\u5206\\u3002\\n\\n### Caveat with StrictMode\\n\\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```'},Pw6v:function(n,e,o){\"use strict\";var t=o(\"z3IF\"),r=o(\"2Fjn\"),i=o(\"mXGw\"),a=o(\"PDtE\"),s=o(\"XpU0\"),c=o(\"rKPb\"),p=i.createElement,m=i.forwardRef((function(n,e){var o=n.classes,i=n.className,s=n.color,m=void 0===s?\"inherit\":s,d=n.component,l=void 0===d?\"span\":d,u=n.fontSize,f=void 0===u?\"default\":u,h=Object(r.a)(n,[\"classes\",\"className\",\"color\",\"component\",\"fontSize\"]);return p(l,Object(t.a)({className:Object(a.a)(\"material-icons\",o.root,i,\"inherit\"!==m&&o[\"color\".concat(Object(c.a)(m))],\"default\"!==f&&o[\"fontSize\".concat(Object(c.a)(f))]),\"aria-hidden\":!0,ref:e},h))}));m.muiName=\"Icon\",e.a=Object(s.default)((function(n){return{root:{userSelect:\"none\",fontSize:n.typography.pxToRem(24),width:\"1em\",height:\"1em\",overflow:\"hidden\",flexShrink:0},colorPrimary:{color:n.palette.primary.main},colorSecondary:{color:n.palette.secondary.main},colorAction:{color:n.palette.action.active},colorError:{color:n.palette.error.main},colorDisabled:{color:n.palette.action.disabled},fontSizeInherit:{fontSize:\"inherit\"},fontSizeSmall:{fontSize:n.typography.pxToRem(20)},fontSizeLarge:{fontSize:n.typography.pxToRem(36)}}}),{name:\"MuiIcon\"})(m)},RQTr:function(n,e){n.exports=\"import React from 'react';\\nimport IconButton from '@material-ui/core/IconButton';\\nimport Icon, { IconProps } from '@material-ui/core/Icon';\\n\\nconst WrappedIcon = (props: IconProps) => <Icon {...props} />;\\nWrappedIcon.muiName = 'Icon';\\n\\nexport default function Composition() {\\n  return (\\n    <div>\\n      <IconButton>\\n        <Icon>alarm</Icon>\\n      </IconButton>\\n      <IconButton>\\n        <WrappedIcon>alarm</WrappedIcon>\\n      </IconButton>\\n    </div>\\n  );\\n}\\n\"},SwC6:function(n,e){n.exports=\"import React from 'react';\\nimport { MemoryRouter as Router } from 'react-router';\\nimport { Link as RouterLink } from 'react-router-dom';\\nimport Button from '@material-ui/core/Button';\\n\\nconst LinkBehavior = React.forwardRef((props, ref) => (\\n  <RouterLink ref={ref} to=\\\"/getting-started/installation/\\\" {...props} />\\n));\\n\\nexport default function ButtonRouter() {\\n  return (\\n    <Router>\\n      <div>\\n        <Button color=\\\"primary\\\" component={RouterLink} to=\\\"/\\\">\\n          With prop forwarding\\n        </Button>\\n        <br />\\n        <Button color=\\\"primary\\\" component={LinkBehavior}>\\n          Without prop forwarding\\n        </Button>\\n      </div>\\n    </Router>\\n  );\\n}\\n\"},TuBN:function(n,e){n.exports=\"import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport { makeStyles } from '@material-ui/core/styles';\\nimport List from '@material-ui/core/List';\\nimport ListItem from '@material-ui/core/ListItem';\\nimport Paper from '@material-ui/core/Paper';\\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\\nimport ListItemText from '@material-ui/core/ListItemText';\\nimport Divider from '@material-ui/core/Divider';\\nimport InboxIcon from '@material-ui/icons/Inbox';\\nimport DraftsIcon from '@material-ui/icons/Drafts';\\nimport Typography from '@material-ui/core/Typography';\\nimport { Route, MemoryRouter } from 'react-router';\\nimport { Link as RouterLink } from 'react-router-dom';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const renderLink = React.useMemo(\\n    () =>\\n      React.forwardRef((itemProps, ref) => (\\n        <RouterLink to={to} ref={ref} {...itemProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={renderLink}>\\n        {icon ? <ListItemIcon>{icon}</ListItemIcon> : null}\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n\\nListItemLink.propTypes = {\\n  icon: PropTypes.element,\\n  primary: PropTypes.string.isRequired,\\n  to: PropTypes.string.isRequired,\\n};\\n\\nconst useStyles = makeStyles({\\n  root: {\\n    width: 360,\\n  },\\n});\\n\\nexport default function ListRouter() {\\n  const classes = useStyles();\\n\\n  return (\\n    <MemoryRouter initialEntries={['/drafts']} initialIndex={0}>\\n      <div className={classes.root}>\\n        <Route>\\n          {({ location }) => (\\n            <Typography gutterBottom>\\n              Current route: {location.pathname}\\n            </Typography>\\n          )}\\n        </Route>\\n        <Paper elevation={0}>\\n          <List aria-label=\\\"main mailbox folders\\\">\\n            <ListItemLink to=\\\"/inbox\\\" primary=\\\"Inbox\\\" icon={<InboxIcon />} />\\n            <ListItemLink to=\\\"/drafts\\\" primary=\\\"Drafts\\\" icon={<DraftsIcon />} />\\n          </List>\\n          <Divider />\\n          <List aria-label=\\\"secondary mailbox folders\\\">\\n            <ListItemLink to=\\\"/trash\\\" primary=\\\"Trash\\\" />\\n            <ListItemLink to=\\\"/spam\\\" primary=\\\"Spam\\\" />\\n          </List>\\n        </Paper>\\n      </div>\\n    </MemoryRouter>\\n  );\\n}\\n\"},Ug6y:function(n,e){n.exports=\"/* eslint-disable jsx-a11y/anchor-is-valid */\\nimport React from 'react';\\nimport { MemoryRouter as Router } from 'react-router';\\nimport {\\n  Link as RouterLink,\\n  LinkProps as RouterLinkProps,\\n} from 'react-router-dom';\\nimport Link from '@material-ui/core/Link';\\nimport { Omit } from '@material-ui/types';\\n\\nconst LinkBehavior = React.forwardRef<any, Omit<RouterLinkProps, 'to'>>(\\n  (props, ref) => (\\n    <RouterLink ref={ref} to=\\\"/getting-started/installation/\\\" {...props} />\\n  ),\\n);\\n\\nexport default function LinkRouter() {\\n  return (\\n    <Router>\\n      <div>\\n        <Link component={RouterLink} to=\\\"/\\\">\\n          With prop forwarding\\n        </Link>\\n        <br />\\n        <Link component={LinkBehavior}>Without prop forwarding</Link>\\n      </div>\\n    </Router>\\n  );\\n}\\n\"},Wcwt:function(n,e,o){(window.__NEXT_P=window.__NEXT_P||[]).push([\"/guides/composition\",function(){return o(\"ylK1\")}])},\"ZD8+\":function(n,e){n.exports='# Komposition\\n\\n<p class=\"description\">Die Material-UI versucht die Komposition so einfach wie m\\xf6glich zu gestalten.</p>\\n\\n## Komponenten verpacken\\n\\nUm maximale Flexibilit\\xe4t und Leistung zu gew\\xe4hrleisten, ben\\xf6tigen wir einen Weg, um die Art der untergeordneten Elemente einer Komponente zu kennen. To solve this problem we tag some of the components with a `muiName` static property when needed.\\n\\nYou may, however, need to wrap a component in order to enhance it, which can conflict with the `muiName` solution. If you wrap a component, verify if that component has this static property set.\\n\\nIf you encounter this issue, you need to use the same tag for your wrapping component that is used with the wrapped component. In addition, you should forward the properties, as the parent component may need to control the wrapped components props.\\n\\nSehen wir uns ein Beispiel an:\\n\\n```jsx\\nconst WrappedIcon = props => <Icon {...props} />;\\nWrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## Component prop\\n\\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\\n\\n### Wie funktioniert das?\\n\\nThe custom component will be rendered by Material-UI like this:\\n\\n```js\\nreturn React.createElement(props.component, props)\\n```\\n\\nBeispielsweise wird die `List` Komponente mit einem `<ul>`-Element gerendert. This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. Aber es gibt auch eine **kleine Einschr\\xe4nkung!**\\n\\n### Vorbehalt beim Inlining\\n\\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. Zum Beispiel, wenn Sie ein benutzerdefiniertes `ListItem` erstellen m\\xf6chten, das als Link fungiert, k\\xf6nnen Sie Folgendes tun:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = props => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f Da wir jedoch eine Inline-Funktion verwenden, um die gerenderte Komponente zu \\xe4ndern, wird die Verkn\\xfcpfung von React bei jedem Rendern des `ListItemLink ` aufgehoben. React aktualisiert nicht nur das DOM unn\\xf6tig, sondern die Wellenvisualisierung des `ListItem` funktioniert auch nicht richtig.\\n\\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let\\'s change the `ListItemLink` component so `CustomLink` always reference the same component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Caveat with prop forwarding\\n\\nYou can take advantage of the prop forwarding to simplify the code. In diesem Beispiel erstellen wir keine Zwischenkomponente:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\\n\\n### Mit TypeScript\\n\\nYou can find the details in the [TypeScript guide](/guides/typescript/#usage-of-component-prop).\\n\\n## Routing libraries\\n\\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\\n\\n### Button\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### List (liste)\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## Vorbehalt bei Refs\\n\\nThis section covers caveats when using a custom component as `children` or for the `component` prop.\\n\\nSome of the components need access to the DOM node. This was previously possible by using `ReactDOM.findDOMNode`. This function is deprecated in favor of `ref` and ref forwarding. However, only the following component types can be given a `ref`:\\n\\n- Any Material-UI component\\n- class components i.e. `React.Component` or `React.PureComponent`\\n- DOM (or host) components e.g. `div` or `button`\\n- [React.forwardRef components](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [React.lazy components](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [React.memo components](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\nIf you don\\'t use one of the above types when using your components in conjunction with Material-UI, you might see a warning from React in your console similar to:\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\nBe aware that you will still get this warning for `lazy` and `memo` components if their wrapped component can\\'t hold a ref.\\n\\nIn some instances an additional warning is issued to help with debugging, similar to:\\n\\n> Ung\\xfcltige `component` Eigenschaft an `ComponentName` \\xfcbergeben. Es wurde ein Elementtyp erwartet, der eine Referenz enthalten kann.\\n\\nOnly the two most common use cases are covered. For more information see [this section in the official React docs](https://reactjs.org/docs/forwarding-refs.html).\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\nUm herauszufinden, ob die Material-UI - Komponente, die Sie verwenden, diese Anforderung hat, \\xfcberpr\\xfcfen Sie API - Dokumentation f\\xfcr diese Komponente. Wenn Sie Refs weiterleiten m\\xfcssen, wird die Beschreibung mit diesem Abschnitt verkn\\xfcpft.\\n\\n### Caveat with StrictMode\\n\\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```'},czfG:function(n,e,o){\"use strict\";var t=o(\"mXGw\"),r=o(\"vtGe\"),i=t.createElement;e.a=Object(r.a)(i(\"path\",{d:\"M19 3H4.99c-1.11 0-1.98.89-1.98 2L3 19c0 1.1.88 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.11-.9-2-2-2zm0 12h-4c0 1.66-1.35 3-3 3s-3-1.34-3-3H4.99V5H19v10z\"}),\"Inbox\")},hd9u:function(n,e,o){var t={\"./ButtonRouter.js\":\"6XOy\",\"./ButtonRouter.tsx\":\"/BS6\",\"./Composition.js\":\"9Dhp\",\"./Composition.tsx\":\"/wNM\",\"./LinkRouter.js\":\"sh0S\",\"./LinkRouter.tsx\":\"qYZ3\",\"./ListRouter.js\":\"4fGY\",\"./ListRouter.tsx\":\"F12Z\"};function r(n){var e=i(n);return o(e)}function i(n){if(!o.o(t,n)){var e=new Error(\"Cannot find module '\"+n+\"'\");throw e.code=\"MODULE_NOT_FOUND\",e}return t[n]}r.keys=function(){return Object.keys(t)},r.resolve=i,n.exports=r,r.id=\"hd9u\"},jyj3:function(n,e){n.exports=\"import React from 'react';\\nimport { makeStyles } from '@material-ui/core/styles';\\nimport List from '@material-ui/core/List';\\nimport ListItem from '@material-ui/core/ListItem';\\nimport Paper from '@material-ui/core/Paper';\\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\\nimport ListItemText from '@material-ui/core/ListItemText';\\nimport Divider from '@material-ui/core/Divider';\\nimport InboxIcon from '@material-ui/icons/Inbox';\\nimport DraftsIcon from '@material-ui/icons/Drafts';\\nimport Typography from '@material-ui/core/Typography';\\nimport { Route, MemoryRouter } from 'react-router';\\nimport {\\n  Link as RouterLink,\\n  LinkProps as RouterLinkProps,\\n} from 'react-router-dom';\\nimport { Omit } from '@material-ui/types';\\n\\ninterface ListItemLinkProps {\\n  icon?: React.ReactElement;\\n  primary: string;\\n  to: string;\\n}\\n\\nfunction ListItemLink(props: ListItemLinkProps) {\\n  const { icon, primary, to } = props;\\n\\n  const renderLink = React.useMemo(\\n    () =>\\n      React.forwardRef<any, Omit<RouterLinkProps, 'to'>>((itemProps, ref) => (\\n        <RouterLink to={to} ref={ref} {...itemProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={renderLink}>\\n        {icon ? <ListItemIcon>{icon}</ListItemIcon> : null}\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n\\nconst useStyles = makeStyles({\\n  root: {\\n    width: 360,\\n  },\\n});\\n\\nexport default function ListRouter() {\\n  const classes = useStyles();\\n\\n  return (\\n    <MemoryRouter initialEntries={['/drafts']} initialIndex={0}>\\n      <div className={classes.root}>\\n        <Route>\\n          {({ location }) => (\\n            <Typography gutterBottom>\\n              Current route: {location.pathname}\\n            </Typography>\\n          )}\\n        </Route>\\n        <Paper elevation={0}>\\n          <List aria-label=\\\"main mailbox folders\\\">\\n            <ListItemLink to=\\\"/inbox\\\" primary=\\\"Inbox\\\" icon={<InboxIcon />} />\\n            <ListItemLink to=\\\"/drafts\\\" primary=\\\"Drafts\\\" icon={<DraftsIcon />} />\\n          </List>\\n          <Divider />\\n          <List aria-label=\\\"secondary mailbox folders\\\">\\n            <ListItemLink to=\\\"/trash\\\" primary=\\\"Trash\\\" />\\n            <ListItemLink to=\\\"/spam\\\" primary=\\\"Spam\\\" />\\n          </List>\\n        </Paper>\\n      </div>\\n    </MemoryRouter>\\n  );\\n}\\n\"},qYZ3:function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return l}));var t=o(\"z3IF\"),r=o(\"mXGw\"),i=o.n(r),a=o(\"oNR1\"),s=o(\"USb2\"),c=o(\"r6IM\"),p=i.a.createElement,m=i.a.forwardRef((function(n,e){return p(s.a,Object(t.a)({ref:e,to:\"/getting-started/installation/\"},n))})),d=p(a.a,null,p(\"div\",null,p(c.a,{component:s.a,to:\"/\"},\"With prop forwarding\"),p(\"br\",null),p(c.a,{component:m},\"Without prop forwarding\")));function l(){return d}},rV5U:function(n,e){n.exports='# Composition\\n\\n<p class=\"description\">Material-UI tries to make composition as easy as possible.</p>\\n\\n## Wrapping components\\n\\nIn order to provide the maximum flexibility and performance,\\nwe need a way to know the nature of the child elements a component receives.\\nTo solve this problem we tag some of the components\\nwith a `muiName` static property when needed.\\n\\nYou may, however, need to wrap a component in order to enhance it,\\nwhich can conflict with the `muiName` solution. If you wrap a component, verify if\\nthat component has this static property set.\\n\\nIf you encounter this issue, you need to use the same tag for your wrapping component\\nthat is used with the wrapped component. In addition, you should forward the properties,\\nas the parent component may need to control the wrapped components props.\\n\\nLet\\'s see an example:\\n\\n```jsx\\nconst WrappedIcon = (props) => <Icon {...props} />;\\nWrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## Component prop\\n\\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\\n\\n### How does it work?\\n\\nThe custom component will be rendered by Material-UI like this:\\n\\n```js\\nreturn React.createElement(props.component, props);\\n```\\n\\nFor example, by default a `List` component will render a `<ul>` element.\\nThis can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop.\\nThe following example will render the `List` component with a `<nav>` element as root element instead:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library.\\nBut it also **comes with a small caveat!**\\n\\n### Caveat with inlining\\n\\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders.\\nFor instance, if you want to create a custom `ListItem` that acts as a link, you could do the following:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = (props) => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f However, since we are using an inline function to change the rendered component, React will unmount the link every time `ListItemLink` is rendered. Not only will React update the DOM unnecessarily, the ripple effect of the `ListItem` will also not work correctly.\\n\\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead.\\nLet\\'s change the `ListItemLink` component so `CustomLink` always reference the same component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Caveat with prop forwarding\\n\\nYou can take advantage of the prop forwarding to simplify the code.\\nIn this example, we don\\'t create any intermediary component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f However, this strategy suffers from a limitation: prop collisions.\\nThe component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\\n\\n### With TypeScript\\n\\nYou can find the details in the [TypeScript guide](/guides/typescript/#usage-of-component-prop).\\n\\n## Routing libraries\\n\\nThe integration with third-party routing libraries is achieved with the `component` prop.\\nThe behavior is identical to the description of the prop above.\\nHere are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router).\\nIt covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\\n\\n### Button\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### List\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## Caveat with refs\\n\\nThis section covers caveats when using a custom component as `children` or for the\\n`component` prop.\\n\\nSome of the components need access to the DOM node. This was previously possible\\nby using `ReactDOM.findDOMNode`. This function is deprecated in favor of `ref` and\\nref forwarding. However, only the following component types can be given a `ref`:\\n\\n- Any Material-UI component\\n- class components i.e. `React.Component` or `React.PureComponent`\\n- DOM (or host) components e.g. `div` or `button`\\n- [React.forwardRef components](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [React.lazy components](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [React.memo components](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\nIf you don\\'t use one of the above types when using your components in conjunction with Material-UI, you might see a warning from\\nReact in your console similar to:\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\nBe aware that you will still get this warning for `lazy` and `memo` components if their\\nwrapped component can\\'t hold a ref.\\n\\nIn some instances an additional warning is issued to help with debugging, similar to:\\n\\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\\n\\nOnly the two most common use cases are covered. For more information see [this section in the official React docs](https://reactjs.org/docs/forwarding-refs.html).\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\nTo find out if the Material-UI component you\\'re using has this requirement, check\\nout the the props API documentation for that component. If you need to forward refs\\nthe description will link to this section.\\n\\n### Caveat with StrictMode\\n\\nIf you use class components for the cases described above you will still see\\nwarnings in `React.StrictMode`.\\n`ReactDOM.findDOMNode` is used internally for backwards compatibility.\\nYou can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component.\\nDoing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```\\n'},rhSz:function(n,e,o){var t={\"./ButtonRouter.js\":\"SwC6\",\"./ButtonRouter.tsx\":\"61vW\",\"./Composition.js\":\"6jai\",\"./Composition.tsx\":\"RQTr\",\"./LinkRouter.js\":\"xgUH\",\"./LinkRouter.tsx\":\"Ug6y\",\"./ListRouter.js\":\"TuBN\",\"./ListRouter.tsx\":\"jyj3\",\"./composition-aa.md\":\"LDqK\",\"./composition-de.md\":\"ZD8+\",\"./composition-es.md\":\"5YrX\",\"./composition-fr.md\":\"y3BP\",\"./composition-ja.md\":\"wJsP\",\"./composition-pt.md\":\"BP5+\",\"./composition-ru.md\":\"x59r\",\"./composition-zh.md\":\"Oin9\",\"./composition.md\":\"rV5U\"};function r(n){var e=i(n);return o(e)}function i(n){if(!o.o(t,n)){var e=new Error(\"Cannot find module '\"+n+\"'\");throw e.code=\"MODULE_NOT_FOUND\",e}return t[n]}r.keys=function(){return Object.keys(t)},r.resolve=i,n.exports=r,r.id=\"rhSz\"},sh0S:function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return l}));var t=o(\"z3IF\"),r=o(\"mXGw\"),i=o.n(r),a=o(\"oNR1\"),s=o(\"USb2\"),c=o(\"r6IM\"),p=i.a.createElement,m=i.a.forwardRef((function(n,e){return p(s.a,Object(t.a)({ref:e,to:\"/getting-started/installation/\"},n))})),d=p(a.a,null,p(\"div\",null,p(c.a,{component:s.a,to:\"/\"},\"With prop forwarding\"),p(\"br\",null),p(c.a,{component:m},\"Without prop forwarding\")));function l(){return d}},\"vR+x\":function(n,e,o){\"use strict\";var t=o(\"z3IF\"),r=o(\"2Fjn\"),i=o(\"mXGw\"),a=o(\"PDtE\"),s=o(\"XpU0\"),c=o(\"k+Qe\"),p=i.createElement,m=i.forwardRef((function(n,e){var o=n.classes,s=n.className,m=Object(r.a)(n,[\"classes\",\"className\"]),d=i.useContext(c.a);return p(\"div\",Object(t.a)({className:Object(a.a)(o.root,s,\"flex-start\"===d.alignItems&&o.alignItemsFlexStart),ref:e},m))}));e.a=Object(s.default)((function(n){return{root:{minWidth:56,color:n.palette.action.active,flexShrink:0,display:\"inline-flex\"},alignItemsFlexStart:{marginTop:8}}}),{name:\"MuiListItemIcon\"})(m)},wJsP:function(n,e){n.exports='# \\u5f93\\u5c5e\\u95a2\\u4fc2\\n\\n<p class=\"description\">Material-UI\\u306f\\u3001\\u69cb\\u6210\\u3092\\u3067\\u304d\\u308b\\u3060\\u3051\\u7c21\\u5358\\u306b\\u3057\\u3088\\u3046\\u3068\\u3057\\u307e\\u3059\\u3002</p>\\n\\n## \\u30e9\\u30c3\\u30d4\\u30f3\\u30b0\\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\n\\n\\u6700\\u5927\\u9650\\u306e\\u67d4\\u8edf\\u6027\\u3068\\u30d1\\u30d5\\u30a9\\u30fc\\u30de\\u30f3\\u30b9\\u3092\\u63d0\\u4f9b\\u3059\\u308b\\u305f\\u3081\\u306b\\u3001 \\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u304c\\u53d7\\u3051\\u53d6\\u308b\\u5b50\\u8981\\u7d20\\u306e\\u6027\\u8cea\\u3092\\u77e5\\u308b\\u65b9\\u6cd5\\u304c\\u5fc5\\u8981\\u3067\\u3059\\u3002 To solve this problem we tag some of the components with a `muiName` static property when needed.\\n\\n\\u305f\\u3060\\u3057\\u3001\\u62e1\\u5f35\\u3059\\u308b\\u305f\\u3081\\u306b\\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u3092\\u30e9\\u30c3\\u30d7\\u3059\\u308b\\u5fc5\\u8981\\u304c\\u3042\\u308b\\u5834\\u5408\\u304c\\u3042\\u308a\\u3001\\u3053\\u308c\\u306f`muiName`\\u30bd\\u30ea\\u30e5\\u30fc\\u30b7\\u30e7\\u30f3\\u3068\\u7af6\\u5408\\u3059\\u308b\\u53ef\\u80fd\\u6027\\u304c\\u3042\\u308a\\u307e\\u3059\\u3002 \\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u3092\\u30e9\\u30c3\\u30d7\\u3059\\u308b\\u5834\\u5408\\u306f\\u3001\\u305d\\u306e\\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u306b\\u3053\\u306e\\u9759\\u7684\\u30d7\\u30ed\\u30d1\\u30c6\\u30a3\\u30fc\\u304c\\u8a2d\\u5b9a\\u3055\\u308c\\u3066\\u3044\\u308b\\u304b\\u3069\\u3046\\u304b\\u3092\\u78ba\\u8a8d\\u3057\\u307e\\u3059\\u3002\\n\\n\\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u3092\\u30e9\\u30c3\\u30d7\\u3059\\u308b\\u5834\\u5408\\u306f\\u3001\\u305d\\u306e\\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u306b\\u3053\\u306e\\u9759\\u7684\\u30d7\\u30ed\\u30d1\\u30c6\\u30a3\\u30fc\\u304c\\u8a2d\\u5b9a\\u3055\\u308c\\u3066\\u3044\\u308b\\u304b\\u3069\\u3046\\u304b\\u3092\\u78ba\\u8a8d\\u3057\\u307e\\u3059\\u3002 \\u3055\\u3089\\u306b\\u3001\\u89aa\\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u304c\\u30e9\\u30c3\\u30d7\\u3055\\u308c\\u305f\\u30b3\\u30f3\\u30dd\\u30fc\\u30cd\\u30f3\\u30c8\\u30d7\\u30ed\\u30d1\\u30c6\\u30a3\\u3092\\u30b3\\u30f3\\u30c8\\u30ed\\u30fc\\u30eb\\u3059\\u308b\\u5fc5\\u8981\\u304c\\u3042\\u308b\\u5834\\u5408\\u304c\\u3042\\u308b\\u305f\\u3081\\u3001\\u30d7\\u30ed\\u30d1\\u30c6\\u30a3\\u3092\\u8ee2\\u9001\\u3059\\u308b\\u5fc5\\u8981\\u304c\\u3042\\u308a\\u307e\\u3059\\u3002\\n\\n\\u4f8b\\u3092\\u898b\\u3066\\u307f\\u307e\\u3057\\u3087\\u3046\\uff1a\\n\\n```jsx\\nconst WrappedIcon = props => <Icon {...props} />;\\nWrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## Component prop\\n\\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\\n\\n### \\u3069\\u306e\\u3088\\u3046\\u306b\\u6a5f\\u80fd\\u3057\\u307e\\u3059\\u304b\\uff1f\\n\\nThe custom component will be rendered by Material-UI like this:\\n\\n```js\\nreturn React.createElement(props.component, props)\\n```\\n\\nFor example, by default a `List` component will render a `<ul>` element. This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. But it also **comes with a small caveat!**\\n\\n### \\u30a4\\u30f3\\u30e9\\u30a4\\u30f3\\u306e\\u3042\\u308b\\u8b66\\u544a\\n\\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. For instance, if you want to create a custom `ListItem` that acts as a link, you could do the following:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = props => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f However, since we are using an inline function to change the rendered component, React will unmount the link every time `ListItemLink` is rendered. Not only will React update the DOM unnecessarily, the ripple effect of the `ListItem` will also not work correctly.\\n\\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let\\'s change the `ListItemLink` component so `CustomLink` always reference the same component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Caveat with prop forwarding\\n\\nYou can take advantage of the prop forwarding to simplify the code. In this example, we don\\'t create any intermediary component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\\n\\n### With TypeScript\\n\\nYou can find the details in the [TypeScript guide](/guides/typescript/#usage-of-component-prop).\\n\\n## Routing libraries\\n\\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\\n\\n### Button (\\u30dc\\u30bf\\u30f3)\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### List (\\u30ea\\u30b9\\u30c8)\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## Caveat with refs\\n\\nThis section covers caveats when using a custom component as `children` or for the `component` prop.\\n\\nSome of the components need access to the DOM node. This was previously possible by using `ReactDOM.findDOMNode`. This function is deprecated in favor of `ref` and ref forwarding. However, only the following component types can be given a `ref`:\\n\\n- Any Material-UI component\\n- class components i.e. `React.Component` or `React.PureComponent`\\n- DOM (or host) components e.g. `div` or `button`\\n- [React.forwardRef components](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [React.lazy components](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [React.memo components](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\nIf you don\\'t use one of the above types when using your components in conjunction with Material-UI, you might see a warning from React in your console similar to:\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\nBe aware that you will still get this warning for `lazy` and `memo` components if their wrapped component can\\'t hold a ref.\\n\\nIn some instances an additional warning is issued to help with debugging, similar to:\\n\\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\\n\\nOnly the two most common use cases are covered. For more information see [this section in the official React docs](https://reactjs.org/docs/forwarding-refs.html).\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\nTo find out if the Material-UI component you\\'re using has this requirement, check out the the props API documentation for that component. If you need to forward refs the description will link to this section.\\n\\n### Caveat with StrictMode\\n\\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```'},x59r:function(n,e){n.exports='# Composition\\n\\n<p class=\"description\">Material-UI tries to make composition as easy as possible.</p>\\n\\n## Wrapping components\\n\\nIn order to provide the maximum flexibility and performance, we need a way to know the nature of the child elements a component receives. To solve this problem we tag some of the components with a `muiName` static property when needed.\\n\\nYou may, however, need to wrap a component in order to enhance it, which can conflict with the `muiName` solution. If you wrap a component, verify if that component has this static property set.\\n\\nIf you encounter this issue, you need to use the same tag for your wrapping component that is used with the wrapped component. In addition, you should forward the properties, as the parent component may need to control the wrapped components props.\\n\\n\\u0414\\u0430\\u0432\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0430\\u0441\\u0441\\u043c\\u043e\\u0442\\u0440\\u0438\\u043c \\u043f\\u0440\\u0438\\u043c\\u0435\\u0440:\\n\\n```jsx\\nconst WrappedIcon = props => <Icon {...props} />; WrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## Component prop\\n\\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\\n\\n### How does it work?\\n\\nThe custom component will be rendered by Material-UI like this:\\n\\n```js\\nreturn React.createElement(props.component, props)\\n```\\n\\n\\u041d\\u0430\\u043f\\u0440\\u0438\\u043c\\u0435\\u0440, \\u043f\\u043e \\u0443\\u043c\\u043e\\u043b\\u0447\\u0430\\u043d\\u0438\\u044e \\u043a\\u043e\\u043c\\u043f\\u043e\\u043d\\u0435\\u043d\\u0442 `List` \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043e\\u0442\\u043e\\u0431\\u0440\\u0430\\u0436\\u0430\\u0442\\u044c `<ul>` \\u044d\\u043b\\u0435\\u043c\\u0435\\u043d\\u0442. This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. \\u041d\\u043e **\\u0441 \\u043d\\u0435\\u0431\\u043e\\u043b\\u044c\\u0448\\u043e\\u0439 \\u043e\\u0433\\u043e\\u0432\\u043e\\u0440\\u043a\\u043e\\u0439! **\\n\\n### Caveat with inlining\\n\\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. \\u041d\\u0430\\u043f\\u0440\\u0438\\u043c\\u0435\\u0440, \\u0435\\u0441\\u043b\\u0438 \\u0432\\u044b \\u0445\\u043e\\u0442\\u0438\\u0442\\u0435 \\u0441\\u043e\\u0437\\u0434\\u0430\\u0442\\u044c \\u0441\\u043e\\u0431\\u0441\\u0442\\u0432\\u0435\\u043d\\u043d\\u044b\\u0439 `ListItem`, \\u043a\\u043e\\u0442\\u043e\\u0440\\u044b\\u0439 \\u0440\\u0430\\u0431\\u043e\\u0442\\u0430\\u0435\\u0442 \\u043a\\u0430\\u043a \\u0441\\u0441\\u044b\\u043b\\u043a\\u0430, \\u0432\\u044b \\u043c\\u043e\\u0436\\u0435\\u0442\\u0435 \\u0441\\u0434\\u0435\\u043b\\u0430\\u0442\\u044c \\u0441\\u043b\\u0435\\u0434\\u0443\\u044e\\u0449\\u0435\\u0435:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = props => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f \\u041e\\u0434\\u043d\\u0430\\u043a\\u043e, \\u043f\\u043e\\u0441\\u043a\\u043e\\u043b\\u044c\\u043a\\u0443 \\u043c\\u044b \\u0438\\u0441\\u043f\\u043e\\u043b\\u044c\\u0437\\u0443\\u0435\\u043c \\u0432\\u0441\\u0442\\u0440\\u043e\\u0435\\u043d\\u043d\\u0443\\u044e \\u0444\\u0443\\u043d\\u043a\\u0446\\u0438\\u044e \\u0434\\u043b\\u044f \\u0438\\u0437\\u043c\\u0435\\u043d\\u0435\\u043d\\u0438\\u044f \\u043e\\u0442\\u0440\\u0438\\u0441\\u043e\\u0432\\u0430\\u043d\\u043d\\u043e\\u0433\\u043e \\u043a\\u043e\\u043c\\u043f\\u043e\\u043d\\u0435\\u043d\\u0442\\u0430, React \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u043c\\u043e\\u043d\\u0442\\u0438\\u0440\\u043e\\u0432\\u0430\\u0442\\u044c \\u0441\\u0441\\u044b\\u043b\\u043a\\u0443 \\u043a\\u0430\\u0436\\u0434\\u044b\\u0439 \\u0440\\u0430\\u0437, \\u043a\\u043e\\u0433\\u0434\\u0430 ` ListItemLink ` \\u043e\\u0442\\u0440\\u0438\\u0441\\u043e\\u0432\\u0430\\u043d. \\u041d\\u0435 \\u0442\\u043e\\u043b\\u044c\\u043a\\u043e React \\u0441\\u0434\\u0435\\u043b\\u0430\\u0435\\u0442 \\u043d\\u0435\\u043d\\u0443\\u0436\\u043d\\u043e\\u0435 \\u043e\\u0431\\u043d\\u043e\\u0432\\u043b\\u0435\\u043d\\u0438\\u0435 DOM, \\u043d\\u043e \\u0438 ripple \\u044d\\u0444\\u0444\\u0435\\u043a\\u0442 `ListItem` \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043e\\u0442\\u0430\\u0442\\u044c \\u043d\\u0435\\u043f\\u0440\\u0430\\u0432\\u0438\\u043b\\u044c\\u043d\\u043e.\\n\\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let\\'s change the `ListItemLink` component so `CustomLink` always reference the same component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Caveat with prop forwarding\\n\\nYou can take advantage of the prop forwarding to simplify the code. \\u0412 \\u044d\\u0442\\u043e\\u043c \\u043f\\u0440\\u0438\\u043c\\u0435\\u0440\\u0435 \\u043c\\u044b \\u043d\\u0435 \\u0441\\u043e\\u0437\\u0434\\u0430\\u0435\\u043c \\u043d\\u0438 \\u043e\\u0434\\u043d\\u043e\\u0433\\u043e \\u043f\\u0440\\u043e\\u043c\\u0435\\u0436\\u0443\\u0442\\u043e\\u0447\\u043d\\u043e\\u0433\\u043e \\u043a\\u043e\\u043c\\u043f\\u043e\\u043d\\u0435\\u043d\\u0442\\u0430:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\\n\\n### With TypeScript\\n\\nYou can find the details in the [TypeScript guide](/guides/typescript/#usage-of-component-prop).\\n\\n## Routing libraries\\n\\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\\n\\n### Button\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### \\u0421\\u043f\\u0438\\u0441\\u043e\\u043a\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## Caveat with refs\\n\\nThis section covers caveats when using a custom component as `children` or for the `component` prop.\\n\\nSome of the components need access to the DOM node. This was previously possible by using `ReactDOM.findDOMNode`. This function is deprecated in favor of `ref` and ref forwarding. However, only the following component types can be given a `ref`:\\n\\n- Any Material-UI component\\n- class components i.e. `React.Component` or `React.PureComponent`\\n- DOM (or host) components e.g. `div` or `button`\\n- [React.forwardRef components](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [React.lazy components](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [React.memo components](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\nIf you don\\'t use one of the above types when using your components in conjunction with Material-UI, you might see a warning from React in your console similar to:\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\nBe aware that you will still get this warning for `lazy` and `memo` components if their wrapped component can\\'t hold a ref.\\n\\nIn some instances an additional warning is issued to help with debugging, similar to:\\n\\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\\n\\nOnly the two most common use cases are covered. For more information see [this section in the official React docs](https://reactjs.org/docs/forwarding-refs.html).\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\nTo find out if the Material-UI component you\\'re using has this requirement, check out the the props API documentation for that component. If you need to forward refs the description will link to this section.\\n\\n### Caveat with StrictMode\\n\\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```'},xgUH:function(n,e){n.exports=\"/* eslint-disable jsx-a11y/anchor-is-valid */\\nimport React from 'react';\\nimport { MemoryRouter as Router } from 'react-router';\\nimport { Link as RouterLink } from 'react-router-dom';\\nimport Link from '@material-ui/core/Link';\\n\\nconst LinkBehavior = React.forwardRef((props, ref) => (\\n  <RouterLink ref={ref} to=\\\"/getting-started/installation/\\\" {...props} />\\n));\\n\\nexport default function LinkRouter() {\\n  return (\\n    <Router>\\n      <div>\\n        <Link component={RouterLink} to=\\\"/\\\">\\n          With prop forwarding\\n        </Link>\\n        <br />\\n        <Link component={LinkBehavior}>Without prop forwarding</Link>\\n      </div>\\n    </Router>\\n  );\\n}\\n\"},y3BP:function(n,e){n.exports='# Composition\\n\\n<p class=\"description\">Material-UI tries to make composition as easy as possible.</p>\\n\\n## Wrapping components\\n\\nIn order to provide the maximum flexibility and performance, we need a way to know the nature of the child elements a component receives. To solve this problem we tag some of the components with a `muiName` static property when needed.\\n\\nYou may, however, need to wrap a component in order to enhance it, which can conflict with the `muiName` solution. If you wrap a component, verify if that component has this static property set.\\n\\nIf you encounter this issue, you need to use the same tag for your wrapping component that is used with the wrapped component. In addition, you should forward the properties, as the parent component may need to control the wrapped components props.\\n\\nLet\\'s see an example:\\n\\n```jsx\\nconst WrappedIcon = props => <Icon {...props} />;\\nWrappedIcon.muiName = Icon.muiName;\\n```\\n\\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\\n\\n## Component prop\\n\\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\\n\\n### Comment cela fonctionne-t-il ?\\n\\nThe custom component will be rendered by Material-UI like this:\\n\\n```js\\nreturn React.createElement(props.component, props)\\n```\\n\\nFor example, by default a `List` component will render a `<ul>` element. This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\\n\\n```jsx\\n<List component=\"nav\">\\n  <ListItem button>\\n    <ListItemText primary=\"Trash\" />\\n  </ListItem>\\n  <ListItem button>\\n    <ListItemText primary=\"Spam\" />\\n  </ListItem>\\n</List>\\n```\\n\\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. But it also **comes with a small caveat!**\\n\\n### Caveat with inlining\\n\\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. For instance, if you want to create a custom `ListItem` that acts as a link, you could do the following:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = props => <Link to={to} {...props} />;\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n\\u26a0\\ufe0f However, since we are using an inline function to change the rendered component, React will unmount the link every time `ListItemLink` is rendered. Not only will React update the DOM unnecessarily, the ripple effect of the `ListItem` will also not work correctly.\\n\\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let\\'s change the `ListItemLink` component so `CustomLink` always reference the same component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\nfunction ListItemLink(props) {\\n  const { icon, primary, to } = props;\\n\\n  const CustomLink = React.useMemo(\\n    () =>\\n      React.forwardRef((linkProps, ref) => (\\n        <Link ref={ref} to={to} {...linkProps} />\\n      )),\\n    [to],\\n  );\\n\\n  return (\\n    <li>\\n      <ListItem button component={CustomLink}>\\n        <ListItemIcon>{icon}</ListItemIcon>\\n        <ListItemText primary={primary} />\\n      </ListItem>\\n    </li>\\n  );\\n}\\n```\\n\\n### Caveat with prop forwarding\\n\\nYou can take advantage of the prop forwarding to simplify the code. In this example, we don\\'t create any intermediary component:\\n\\n```jsx\\nimport { Link } from \\'react-router-dom\\';\\n\\n<ListItem button component={Link} to=\"/\">\\n```\\n\\n\\u26a0\\ufe0f However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\\n\\n### Avec TypeScript\\n\\nYou can find the details in the [TypeScript guide](/guides/typescript/#usage-of-component-prop).\\n\\n## Routing libraries\\n\\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\\n\\n### Button\\n\\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\\n\\n### Link\\n\\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\\n\\n### List (Liste)\\n\\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\\n\\n## Caveat with refs\\n\\nThis section covers caveats when using a custom component as `children` or for the `component` prop.\\n\\nSome of the components need access to the DOM node. This was previously possible by using `ReactDOM.findDOMNode`. This function is deprecated in favor of `ref` and ref forwarding. However, only the following component types can be given a `ref`:\\n\\n- Any Material-UI component\\n- class components i.e. `React.Component` or `React.PureComponent`\\n- DOM (or host) components e.g. `div` or `button`\\n- [React.forwardRef components](https://reactjs.org/docs/react-api.html#reactforwardref)\\n- [React.lazy components](https://reactjs.org/docs/react-api.html#reactlazy)\\n- [React.memo components](https://reactjs.org/docs/react-api.html#reactmemo)\\n\\nIf you don\\'t use one of the above types when using your components in conjunction with Material-UI, you might see a warning from React in your console similar to:\\n\\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\\n\\nBe aware that you will still get this warning for `lazy` and `memo` components if their wrapped component can\\'t hold a ref.\\n\\nIn some instances an additional warning is issued to help with debugging, similar to:\\n\\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\\n\\nOnly the two most common use cases are covered. For more information see [this section in the official React docs](https://reactjs.org/docs/forwarding-refs.html).\\n\\n```diff\\n-const MyButton = props => <div role=\"button\" {...props} />;\\n+const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\\n<Button component={MyButton} />;\\n```\\n\\n```diff\\n-const SomeContent = props => <div {...props}>Hello, World!</div>;\\n+const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\\n```\\n\\nTo find out if the Material-UI component you\\'re using has this requirement, check out the the props API documentation for that component. If you need to forward refs the description will link to this section.\\n\\n### Caveat with StrictMode\\n\\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\\n\\n```diff\\nclass Component extends React.Component {\\n  render() {\\n-   const { props } = this;\\n+   const { forwardedRef, ...props } = this.props;\\n    return <div {...props} ref={forwardedRef} />;\\n  }\\n}\\n\\n-export default Component;\\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\\n```'},ylK1:function(n,e,o){\"use strict\";o.r(e),o.d(e,\"default\",(function(){return m}));var t=o(\"mXGw\"),r=o.n(t),i=o(\"e+1t\"),a=o(\"kVtE\"),s=r.a.createElement,c=o(\"hd9u\"),p=o(\"rhSz\");function m(n){var e=n.demos,o=n.docs;return s(i.a,{demos:e,docs:o,requireDemo:c})}m.getInitialProps=function(){var n=Object(a.a)({pageFilename:\"guides/composition\",requireRaw:p});return{demos:n.demos,docs:n.docs}}}},[[\"Wcwt\",0,2,1,3,5,4,6,7,8,9,10,11,12,15,13,14,16,17,18,32]]]);"}