{"ast":null,"code":"import _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _parseInt from \"@babel/runtime-corejs2/core-js/parse-int\";\nimport getScrollbarSize from \"../utils/getScrollbarSize\";\nimport ownerDocument from \"../utils/ownerDocument\";\nimport ownerWindow from \"../utils/ownerWindow\"; // Is a vertical scrollbar displayed?\n\nfunction isOverflowing(container) {\n  var doc = ownerDocument(container);\n\n  if (doc.body === container) {\n    return ownerWindow(doc).innerWidth > doc.documentElement.clientWidth;\n  }\n\n  return container.scrollHeight > container.clientHeight;\n}\n\nexport function ariaHidden(node, show) {\n  if (show) {\n    node.setAttribute('aria-hidden', 'true');\n  } else {\n    node.removeAttribute('aria-hidden');\n  }\n}\n\nfunction getPaddingRight(node) {\n  return _parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;\n}\n\nfunction ariaHiddenSiblings(container, mountNode, currentNode) {\n  var nodesToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var show = arguments.length > 4 ? arguments[4] : undefined;\n  var blacklist = [mountNode, currentNode].concat(_toConsumableArray(nodesToExclude));\n  var blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];\n  [].forEach.call(container.children, function (node) {\n    if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) {\n      ariaHidden(node, show);\n    }\n  });\n}\n\nfunction findIndexOf(containerInfo, callback) {\n  var idx = -1;\n  containerInfo.some(function (item, index) {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n\n    return false;\n  });\n  return idx;\n}\n\nfunction handleContainer(containerInfo, props) {\n  var restoreStyle = [];\n  var restorePaddings = [];\n  var container = containerInfo.container;\n  var fixedNodes;\n\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      var scrollbarSize = getScrollbarSize();\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        key: 'padding-right',\n        el: container\n      }); // Use computed style, here to get the real padding to add our scrollbar width.\n\n      container.style['padding-right'] = \"\".concat(getPaddingRight(container) + scrollbarSize, \"px\"); // .mui-fixed is a global helper.\n\n      fixedNodes = ownerDocument(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedNodes, function (node) {\n        restorePaddings.push(node.style.paddingRight);\n        node.style.paddingRight = \"\".concat(getPaddingRight(node) + scrollbarSize, \"px\");\n      });\n    } // Improve Gatsby support\n    // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n\n\n    var parent = container.parentElement;\n    var scrollContainer = parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      key: 'overflow',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n\n  var restore = function restore() {\n    if (fixedNodes) {\n      [].forEach.call(fixedNodes, function (node, i) {\n        if (restorePaddings[i]) {\n          node.style.paddingRight = restorePaddings[i];\n        } else {\n          node.style.removeProperty('padding-right');\n        }\n      });\n    }\n\n    restoreStyle.forEach(function (_ref) {\n      var value = _ref.value,\n          el = _ref.el,\n          key = _ref.key;\n\n      if (value) {\n        el.style.setProperty(key, value);\n      } else {\n        el.style.removeProperty(key);\n      }\n    });\n  };\n\n  return restore;\n}\n\nfunction getHiddenSiblings(container) {\n  var hiddenSiblings = [];\n  [].forEach.call(container.children, function (node) {\n    if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(node);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\n\n\nvar ModalManager = /*#__PURE__*/function () {\n  function ModalManager() {\n    _classCallCheck(this, ModalManager);\n\n    // this.modals[modalIndex] = modal\n    this.modals = []; // this.containers[containerIndex] = {\n    //   modals: [],\n    //   container,\n    //   restore: null,\n    // }\n\n    this.containers = [];\n  }\n\n  _createClass(ModalManager, [{\n    key: \"add\",\n    value: function add(modal, container) {\n      var modalIndex = this.modals.indexOf(modal);\n\n      if (modalIndex !== -1) {\n        return modalIndex;\n      }\n\n      modalIndex = this.modals.length;\n      this.modals.push(modal); // If the modal we are adding is already in the DOM.\n\n      if (modal.modalRef) {\n        ariaHidden(modal.modalRef, false);\n      }\n\n      var hiddenSiblingNodes = getHiddenSiblings(container);\n      ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.container === container;\n      });\n\n      if (containerIndex !== -1) {\n        this.containers[containerIndex].modals.push(modal);\n        return modalIndex;\n      }\n\n      this.containers.push({\n        modals: [modal],\n        container: container,\n        restore: null,\n        hiddenSiblingNodes: hiddenSiblingNodes\n      });\n      return modalIndex;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(modal, props) {\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var containerInfo = this.containers[containerIndex];\n\n      if (!containerInfo.restore) {\n        containerInfo.restore = handleContainer(containerInfo, props);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(modal) {\n      var modalIndex = this.modals.indexOf(modal);\n\n      if (modalIndex === -1) {\n        return modalIndex;\n      }\n\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var containerInfo = this.containers[containerIndex];\n      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n      this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.\n\n      if (containerInfo.modals.length === 0) {\n        // The modal might be closed before it had the chance to be mounted in the DOM.\n        if (containerInfo.restore) {\n          containerInfo.restore();\n        }\n\n        if (modal.modalRef) {\n          // In case the modal wasn't in the DOM yet.\n          ariaHidden(modal.modalRef, true);\n        }\n\n        ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);\n        this.containers.splice(containerIndex, 1);\n      } else {\n        // Otherwise make sure the next top modal is visible to a screen reader.\n        var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set\n        // aria-hidden because the dom element doesn't exist either\n        // when modal was unmounted before modalRef gets null\n\n        if (nextTop.modalRef) {\n          ariaHidden(nextTop.modalRef, false);\n        }\n      }\n\n      return modalIndex;\n    }\n  }, {\n    key: \"isTopModal\",\n    value: function isTopModal(modal) {\n      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n    }\n  }]);\n\n  return ModalManager;\n}();\n\nexport { ModalManager as default };","map":{"version":3,"sources":["/home/marcelo.faria/Documentos/b2w/msf-ui/packages/material-ui/src/Modal/ModalManager.js"],"names":["getScrollbarSize","ownerDocument","ownerWindow","isOverflowing","container","doc","body","innerWidth","documentElement","clientWidth","scrollHeight","clientHeight","ariaHidden","node","show","setAttribute","removeAttribute","getPaddingRight","window","getComputedStyle","ariaHiddenSiblings","mountNode","currentNode","nodesToExclude","blacklist","blacklistTagNames","forEach","call","children","nodeType","indexOf","tagName","findIndexOf","containerInfo","callback","idx","some","item","index","handleContainer","props","restoreStyle","restorePaddings","fixedNodes","disableScrollLock","scrollbarSize","push","value","style","paddingRight","key","el","querySelectorAll","parent","parentElement","scrollContainer","nodeName","overflow","restore","i","removeProperty","setProperty","getHiddenSiblings","hiddenSiblings","getAttribute","ModalManager","modals","containers","modal","modalIndex","length","modalRef","hiddenSiblingNodes","containerIndex","splice","nextTop"],"mappings":"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","sourcesContent":["import getScrollbarSize from '../utils/getScrollbarSize';\nimport ownerDocument from '../utils/ownerDocument';\nimport ownerWindow from '../utils/ownerWindow';\n\n// Is a vertical scrollbar displayed?\nfunction isOverflowing(container) {\n  const doc = ownerDocument(container);\n\n  if (doc.body === container) {\n    return ownerWindow(doc).innerWidth > doc.documentElement.clientWidth;\n  }\n\n  return container.scrollHeight > container.clientHeight;\n}\n\nexport function ariaHidden(node, show) {\n  if (show) {\n    node.setAttribute('aria-hidden', 'true');\n  } else {\n    node.removeAttribute('aria-hidden');\n  }\n}\n\nfunction getPaddingRight(node) {\n  return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;\n}\n\nfunction ariaHiddenSiblings(container, mountNode, currentNode, nodesToExclude = [], show) {\n  const blacklist = [mountNode, currentNode, ...nodesToExclude];\n  const blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];\n\n  [].forEach.call(container.children, (node) => {\n    if (\n      node.nodeType === 1 &&\n      blacklist.indexOf(node) === -1 &&\n      blacklistTagNames.indexOf(node.tagName) === -1\n    ) {\n      ariaHidden(node, show);\n    }\n  });\n}\n\nfunction findIndexOf(containerInfo, callback) {\n  let idx = -1;\n  containerInfo.some((item, index) => {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n    return false;\n  });\n  return idx;\n}\n\nfunction handleContainer(containerInfo, props) {\n  const restoreStyle = [];\n  const restorePaddings = [];\n  const container = containerInfo.container;\n  let fixedNodes;\n\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      const scrollbarSize = getScrollbarSize();\n\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        key: 'padding-right',\n        el: container,\n      });\n      // Use computed style, here to get the real padding to add our scrollbar width.\n      container.style['padding-right'] = `${getPaddingRight(container) + scrollbarSize}px`;\n\n      // .mui-fixed is a global helper.\n      fixedNodes = ownerDocument(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedNodes, (node) => {\n        restorePaddings.push(node.style.paddingRight);\n        node.style.paddingRight = `${getPaddingRight(node) + scrollbarSize}px`;\n      });\n    }\n\n    // Improve Gatsby support\n    // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n    const parent = container.parentElement;\n    const scrollContainer =\n      parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll'\n        ? parent\n        : container;\n\n    // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      key: 'overflow',\n      el: scrollContainer,\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n\n  const restore = () => {\n    if (fixedNodes) {\n      [].forEach.call(fixedNodes, (node, i) => {\n        if (restorePaddings[i]) {\n          node.style.paddingRight = restorePaddings[i];\n        } else {\n          node.style.removeProperty('padding-right');\n        }\n      });\n    }\n\n    restoreStyle.forEach(({ value, el, key }) => {\n      if (value) {\n        el.style.setProperty(key, value);\n      } else {\n        el.style.removeProperty(key);\n      }\n    });\n  };\n\n  return restore;\n}\n\nfunction getHiddenSiblings(container) {\n  const hiddenSiblings = [];\n  [].forEach.call(container.children, (node) => {\n    if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(node);\n    }\n  });\n  return hiddenSiblings;\n}\n\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\nexport default class ModalManager {\n  constructor() {\n    // this.modals[modalIndex] = modal\n    this.modals = [];\n    // this.containers[containerIndex] = {\n    //   modals: [],\n    //   container,\n    //   restore: null,\n    // }\n    this.containers = [];\n  }\n\n  add(modal, container) {\n    let modalIndex = this.modals.indexOf(modal);\n    if (modalIndex !== -1) {\n      return modalIndex;\n    }\n\n    modalIndex = this.modals.length;\n    this.modals.push(modal);\n\n    // If the modal we are adding is already in the DOM.\n    if (modal.modalRef) {\n      ariaHidden(modal.modalRef, false);\n    }\n\n    const hiddenSiblingNodes = getHiddenSiblings(container);\n    ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);\n\n    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);\n    if (containerIndex !== -1) {\n      this.containers[containerIndex].modals.push(modal);\n      return modalIndex;\n    }\n\n    this.containers.push({\n      modals: [modal],\n      container,\n      restore: null,\n      hiddenSiblingNodes,\n    });\n\n    return modalIndex;\n  }\n\n  mount(modal, props) {\n    const containerIndex = findIndexOf(\n      this.containers,\n      (item) => item.modals.indexOf(modal) !== -1,\n    );\n    const containerInfo = this.containers[containerIndex];\n\n    if (!containerInfo.restore) {\n      containerInfo.restore = handleContainer(containerInfo, props);\n    }\n  }\n\n  remove(modal) {\n    const modalIndex = this.modals.indexOf(modal);\n\n    if (modalIndex === -1) {\n      return modalIndex;\n    }\n\n    const containerIndex = findIndexOf(\n      this.containers,\n      (item) => item.modals.indexOf(modal) !== -1,\n    );\n    const containerInfo = this.containers[containerIndex];\n\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n    this.modals.splice(modalIndex, 1);\n\n    // If that was the last modal in a container, clean up the container.\n    if (containerInfo.modals.length === 0) {\n      // The modal might be closed before it had the chance to be mounted in the DOM.\n      if (containerInfo.restore) {\n        containerInfo.restore();\n      }\n\n      if (modal.modalRef) {\n        // In case the modal wasn't in the DOM yet.\n        ariaHidden(modal.modalRef, true);\n      }\n\n      ariaHiddenSiblings(\n        containerInfo.container,\n        modal.mountNode,\n        modal.modalRef,\n        containerInfo.hiddenSiblingNodes,\n        false,\n      );\n      this.containers.splice(containerIndex, 1);\n    } else {\n      // Otherwise make sure the next top modal is visible to a screen reader.\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];\n      // as soon as a modal is adding its modalRef is undefined. it can't set\n      // aria-hidden because the dom element doesn't exist either\n      // when modal was unmounted before modalRef gets null\n      if (nextTop.modalRef) {\n        ariaHidden(nextTop.modalRef, false);\n      }\n    }\n\n    return modalIndex;\n  }\n\n  isTopModal(modal) {\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}