{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport marked from 'marked/lib/marked';\nimport { LANGUAGES_IN_PROGRESS } from \"../constants\";\nimport kebabCase from 'lodash/kebabCase';\nimport { rewriteUrlForNextExport } from 'next/dist/next-server/lib/router/rewrite-url-for-export';\nimport textToHash from \"./textToHash\";\nimport prism from \"./prism\";\nconst headerRegExp = /---[\\r\\n]([\\s\\S]*)[\\r\\n]---/;\nconst titleRegExp = /# (.*)[\\r\\n]/;\nconst descriptionRegExp = /<p class=\"description\">(.*)<\\/p>[\\r\\n]/;\nconst headerKeyValueRegExp = /(.*): (.*)/g;\nconst emptyRegExp = /^\\s*$/;\nconst notEnglishMarkdownRegExp = /-([a-z]{2})\\.md$/;\n/**\n * Extract information from the top of the markdown.\n * For instance, the following input:\n *\n * ---\n * title: Backdrop React Component\n * components: Backdrop\n * ---\n *\n * # Backdrop\n *\n * should output:\n * { title: 'Backdrop React Component', components: ['Backdrop'] }\n */\n\nexport function getHeaders(markdown) {\n  let header = markdown.match(headerRegExp);\n\n  if (!header) {\n    return {\n      components: []\n    };\n  }\n\n  header = header[1];\n  let regexMatches;\n  const headers = {}; // eslint-disable-next-line no-cond-assign\n\n  while ((regexMatches = headerKeyValueRegExp.exec(header)) !== null) {\n    headers[regexMatches[1]] = regexMatches[2];\n  }\n\n  if (headers.components) {\n    headers.components = headers.components.split(',').map(x => x.trim()).sort();\n  } else {\n    headers.components = [];\n  }\n\n  return headers;\n}\nexport const demoRegexp = /^\"demo\": \"(.*)\"/;\nexport function getContents(markdown) {\n  return markdown.replace(headerRegExp, '') // Remove header information\n  .split(/^{{(\"demo\":[^}]*)}}$/gm) // Split markdown into an array, separating demos\n  .filter(content => !emptyRegExp.test(content)); // Remove empty lines\n}\nexport function getTitle(markdown) {\n  const matches = markdown.match(titleRegExp);\n\n  if (!matches || !matches[1]) {\n    throw new Error('Missing title in the page');\n  }\n\n  return matches[1];\n}\nexport function getDescription(markdown) {\n  const matches = markdown.match(descriptionRegExp);\n  return matches === null || matches === void 0 ? void 0 : matches[1];\n}\n/**\n * Render markdown used in the Material-UI docs\n *\n * @param {string} markdown\n * @param {object} [options]\n * @param {function} [options.highlight] - https://marked.js.org/#/USING_ADVANCED.md#highlight\n * @param {object} [options.rest] - properties from https://marked.js.org/#/USING_PRO.md#renderer\n */\n\nexport function render(markdown, options = {}) {\n  const {\n    highlight\n  } = options,\n        rendererOptions = _objectWithoutProperties(options, [\"highlight\"]);\n\n  const renderer = _extends(new marked.Renderer(), rendererOptions);\n\n  const markedOptions = {\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: false,\n    smartLists: true,\n    smartypants: false,\n    highlight,\n    renderer\n  };\n  return marked(markdown, markedOptions);\n}\nconst externs = ['https://material.io/', 'https://getbootstrap.com/', 'https://www.amazon.com/', 'https://materialdesignicons.com/', 'https://www.w3.org/', 'https://devexpress.github.io/', 'https://ui-kit.co/'];\n/**\n *\n * @param {object} config\n * @param {() => string} config.requireRaw - returnvalue of require.context\n * @param {string} config.pageFilename - filename relative to nextjs pages directory\n */\n\nexport function prepareMarkdown(config) {\n  const {\n    pageFilename,\n    requireRaw\n  } = config;\n  const demos = {};\n  const docs = {};\n  const headingHashes = {}; // Process the English markdown before the other locales.\n\n  let filenames = [];\n  requireRaw.keys().forEach(filename => {\n    if (filename.match(notEnglishMarkdownRegExp)) {\n      filenames.push(filename);\n    } else {\n      filenames = [filename].concat(filenames);\n    }\n  });\n  filenames.forEach(filename => {\n    if (filename.indexOf('.md') !== -1) {\n      const matchNotEnglishMarkdown = filename.match(notEnglishMarkdownRegExp);\n      const userLanguage = matchNotEnglishMarkdown && LANGUAGES_IN_PROGRESS.indexOf(matchNotEnglishMarkdown[1]) !== -1 ? matchNotEnglishMarkdown[1] : 'en';\n      const markdown = requireRaw(filename);\n      const headers = getHeaders(markdown);\n      const title = headers.title || getTitle(markdown);\n      const description = headers.description || getDescription(markdown);\n      const contents = getContents(markdown);\n\n      if (headers.components.length > 0) {\n        contents.push(`\n## API\n\n${headers.components.map(component => `- [\\`<${component} />\\`](${rewriteUrlForNextExport(`/api/${kebabCase(component)}`)})`).join('\\n')}\n  `);\n      }\n\n      const toc = [];\n      const headingHashesFallbackTranslated = {};\n      let headingIndex = -1;\n      const rendered = contents.map(content => {\n        if (demos && demoRegexp.test(content)) {\n          try {\n            return JSON.parse(`{${content}}`);\n          } catch (err) {\n            console.error('JSON.parse fails with: ', `{${content}}`);\n            console.error(err);\n            return null;\n          }\n        }\n\n        return render(content, {\n          highlight: prism,\n          heading: (headingHtml, level) => {\n            // Small title. No need for an anchor.\n            // It's reducing the risk of duplicated id and it's fewer elements in the DOM.\n            if (level >= 4) {\n              return `<h${level}>${headingHtml}</h${level}>`;\n            }\n\n            const headingText = headingHtml.replace(/([\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])\\uFE0F?/g, '') // remove emojis\n            .replace(/<\\/?[^>]+(>|$)/g, '') // remove HTML\n            .trim(); // Standardizes the hash from the default location (en) to different locations\n            // Need english.md file parsed first\n\n            let hash;\n\n            if (userLanguage === 'en') {\n              hash = textToHash(headingText, headingHashes);\n            } else {\n              headingIndex += 1;\n              hash = Object.keys(headingHashes)[headingIndex];\n\n              if (!hash) {\n                hash = textToHash(headingText, headingHashesFallbackTranslated);\n              }\n            } // enable splitting of long words from function name + first arg name\n            // Closing parens are less interesting since this would only allow breaking one character earlier.\n            // Applying the same mechanism would also allow breaking of non-function signatures like \"Community help (free)\".\n            // To detect that we enabled breaking of open/closing parens we'd need a context-sensitive parser.\n\n\n            const displayText = headingText.replace(/([^\\s]\\()/g, '$1&#8203;'); // create a nested structure with 2 levels starting with level 2 e.g.\n            // [{...level2, children: [level3, level3, level3]}, level2]\n\n            if (level === 2) {\n              toc.push({\n                text: displayText,\n                level,\n                hash,\n                children: []\n              });\n            } else if (level === 3) {\n              if (!toc[toc.length - 1]) {\n                throw new Error(`Missing parent level for: ${headingText}`);\n              }\n\n              toc[toc.length - 1].children.push({\n                text: displayText,\n                level,\n                hash\n              });\n            }\n\n            return [`<h${level}>`, `<a class=\"anchor-link\" id=\"${hash}\"></a>`, headingHtml, `<a class=\"anchor-link-style\" aria-hidden=\"true\" aria-label=\"anchor\" href=\"#${hash}\">`, '<svg><use xlink:href=\"#anchor-link-icon\" /></svg>', '</a>', `</h${level}>`].join('');\n          },\n          link: (href, linkTitle, linkText) => {\n            let more = '';\n\n            if (externs.some(domain => href.indexOf(domain) !== -1)) {\n              more = ' target=\"_blank\" rel=\"noopener nofollow\"';\n            }\n\n            let finalHref = href;\n\n            if (userLanguage !== 'en' && finalHref.indexOf('/') === 0 && finalHref !== '/size-snapshot') {\n              finalHref = `/${userLanguage}${finalHref}`;\n            }\n\n            return `<a href=\"${finalHref}\"${more}>${linkText}</a>`;\n          }\n        });\n      }); // fragment link symbol\n\n      rendered.unshift(`<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n  <symbol id=\"anchor-link-icon\" viewBox=\"0 0 16 16\">\n    <path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\" />\n  </symbol>\n</svg>`);\n      docs[userLanguage] = {\n        description,\n        location: headers.filename || `/docs/src/pages/${pageFilename}/${filename}`,\n        rendered,\n        toc,\n        title\n      };\n    } else if (filename.indexOf('.tsx') !== -1) {\n      const demoName = `pages/${pageFilename}/${filename.replace(/\\.\\//g, '').replace(/\\.tsx/g, '.js')}`;\n      demos[demoName] = _objectSpread(_objectSpread({}, demos[demoName]), {}, {\n        moduleTS: filename,\n        rawTS: requireRaw(filename)\n      });\n    } else {\n      const demoName = `pages/${pageFilename}/${filename.replace(/\\.\\//g, '')}`;\n      demos[demoName] = _objectSpread(_objectSpread({}, demos[demoName]), {}, {\n        module: filename,\n        raw: requireRaw(filename)\n      });\n    }\n  });\n  return {\n    demos,\n    docs\n  };\n}","map":{"version":3,"sources":["/home/marcelo.faria/Documentos/b2w/msf-ui/docs/src/modules/utils/parseMarkdown.js"],"names":["marked","LANGUAGES_IN_PROGRESS","kebabCase","rewriteUrlForNextExport","textToHash","prism","headerRegExp","titleRegExp","descriptionRegExp","headerKeyValueRegExp","emptyRegExp","notEnglishMarkdownRegExp","getHeaders","markdown","header","match","components","regexMatches","headers","exec","split","map","x","trim","sort","demoRegexp","getContents","replace","filter","content","test","getTitle","matches","Error","getDescription","render","options","highlight","rendererOptions","renderer","Renderer","markedOptions","gfm","tables","breaks","pedantic","sanitize","smartLists","smartypants","externs","prepareMarkdown","config","pageFilename","requireRaw","demos","docs","headingHashes","filenames","keys","forEach","filename","push","concat","indexOf","matchNotEnglishMarkdown","userLanguage","title","description","contents","length","component","join","toc","headingHashesFallbackTranslated","headingIndex","rendered","JSON","parse","err","console","error","heading","headingHtml","level","headingText","hash","Object","displayText","text","children","link","href","linkTitle","linkText","more","some","domain","finalHref","unshift","location","demoName","moduleTS","rawTS","module","raw"],"mappings":"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","sourcesContent":["import marked from 'marked/lib/marked';\nimport { LANGUAGES_IN_PROGRESS } from 'docs/src/modules/constants';\nimport kebabCase from 'lodash/kebabCase';\nimport { rewriteUrlForNextExport } from 'next/dist/next-server/lib/router/rewrite-url-for-export';\nimport textToHash from 'docs/src/modules/utils/textToHash';\nimport prism from 'docs/src/modules/utils/prism';\n\nconst headerRegExp = /---[\\r\\n]([\\s\\S]*)[\\r\\n]---/;\nconst titleRegExp = /# (.*)[\\r\\n]/;\nconst descriptionRegExp = /<p class=\"description\">(.*)<\\/p>[\\r\\n]/;\nconst headerKeyValueRegExp = /(.*): (.*)/g;\nconst emptyRegExp = /^\\s*$/;\nconst notEnglishMarkdownRegExp = /-([a-z]{2})\\.md$/;\n\n/**\n * Extract information from the top of the markdown.\n * For instance, the following input:\n *\n * ---\n * title: Backdrop React Component\n * components: Backdrop\n * ---\n *\n * # Backdrop\n *\n * should output:\n * { title: 'Backdrop React Component', components: ['Backdrop'] }\n */\nexport function getHeaders(markdown) {\n  let header = markdown.match(headerRegExp);\n\n  if (!header) {\n    return {\n      components: [],\n    };\n  }\n\n  header = header[1];\n\n  let regexMatches;\n  const headers = {};\n\n  // eslint-disable-next-line no-cond-assign\n  while ((regexMatches = headerKeyValueRegExp.exec(header)) !== null) {\n    headers[regexMatches[1]] = regexMatches[2];\n  }\n\n  if (headers.components) {\n    headers.components = headers.components\n      .split(',')\n      .map((x) => x.trim())\n      .sort();\n  } else {\n    headers.components = [];\n  }\n\n  return headers;\n}\n\nexport const demoRegexp = /^\"demo\": \"(.*)\"/;\n\nexport function getContents(markdown) {\n  return markdown\n    .replace(headerRegExp, '') // Remove header information\n    .split(/^{{(\"demo\":[^}]*)}}$/gm) // Split markdown into an array, separating demos\n    .filter((content) => !emptyRegExp.test(content)); // Remove empty lines\n}\n\nexport function getTitle(markdown) {\n  const matches = markdown.match(titleRegExp);\n\n  if (!matches || !matches[1]) {\n    throw new Error('Missing title in the page');\n  }\n\n  return matches[1];\n}\n\nexport function getDescription(markdown) {\n  const matches = markdown.match(descriptionRegExp);\n\n  return matches?.[1];\n}\n\n/**\n * Render markdown used in the Material-UI docs\n *\n * @param {string} markdown\n * @param {object} [options]\n * @param {function} [options.highlight] - https://marked.js.org/#/USING_ADVANCED.md#highlight\n * @param {object} [options.rest] - properties from https://marked.js.org/#/USING_PRO.md#renderer\n */\nexport function render(markdown, options = {}) {\n  const { highlight, ...rendererOptions } = options;\n\n  const renderer = Object.assign(new marked.Renderer(), rendererOptions);\n\n  const markedOptions = {\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: false,\n    smartLists: true,\n    smartypants: false,\n    highlight,\n    renderer,\n  };\n\n  return marked(markdown, markedOptions);\n}\n\nconst externs = [\n  'https://material.io/',\n  'https://getbootstrap.com/',\n  'https://www.amazon.com/',\n  'https://materialdesignicons.com/',\n  'https://www.w3.org/',\n  'https://devexpress.github.io/',\n  'https://ui-kit.co/',\n];\n\n/**\n *\n * @param {object} config\n * @param {() => string} config.requireRaw - returnvalue of require.context\n * @param {string} config.pageFilename - filename relative to nextjs pages directory\n */\nexport function prepareMarkdown(config) {\n  const { pageFilename, requireRaw } = config;\n\n  const demos = {};\n  const docs = {};\n  const headingHashes = {};\n\n  // Process the English markdown before the other locales.\n  let filenames = [];\n  requireRaw.keys().forEach((filename) => {\n    if (filename.match(notEnglishMarkdownRegExp)) {\n      filenames.push(filename);\n    } else {\n      filenames = [filename].concat(filenames);\n    }\n  });\n\n  filenames.forEach((filename) => {\n    if (filename.indexOf('.md') !== -1) {\n      const matchNotEnglishMarkdown = filename.match(notEnglishMarkdownRegExp);\n\n      const userLanguage =\n        matchNotEnglishMarkdown && LANGUAGES_IN_PROGRESS.indexOf(matchNotEnglishMarkdown[1]) !== -1\n          ? matchNotEnglishMarkdown[1]\n          : 'en';\n\n      const markdown = requireRaw(filename);\n      const headers = getHeaders(markdown);\n      const title = headers.title || getTitle(markdown);\n      const description = headers.description || getDescription(markdown);\n      const contents = getContents(markdown);\n\n      if (headers.components.length > 0) {\n        contents.push(`\n## API\n\n${headers.components\n  .map(\n    (component) =>\n      `- [\\`<${component} />\\`](${rewriteUrlForNextExport(`/api/${kebabCase(component)}`)})`,\n  )\n  .join('\\n')}\n  `);\n      }\n\n      const toc = [];\n      const headingHashesFallbackTranslated = {};\n      let headingIndex = -1;\n\n      const rendered = contents.map((content) => {\n        if (demos && demoRegexp.test(content)) {\n          try {\n            return JSON.parse(`{${content}}`);\n          } catch (err) {\n            console.error('JSON.parse fails with: ', `{${content}}`);\n            console.error(err);\n            return null;\n          }\n        }\n\n        return render(content, {\n          highlight: prism,\n          heading: (headingHtml, level) => {\n            // Small title. No need for an anchor.\n            // It's reducing the risk of duplicated id and it's fewer elements in the DOM.\n            if (level >= 4) {\n              return `<h${level}>${headingHtml}</h${level}>`;\n            }\n\n            const headingText = headingHtml\n              .replace(\n                /([\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])\\uFE0F?/g,\n                '',\n              ) // remove emojis\n              .replace(/<\\/?[^>]+(>|$)/g, '') // remove HTML\n              .trim();\n\n            // Standardizes the hash from the default location (en) to different locations\n            // Need english.md file parsed first\n            let hash;\n            if (userLanguage === 'en') {\n              hash = textToHash(headingText, headingHashes);\n            } else {\n              headingIndex += 1;\n              hash = Object.keys(headingHashes)[headingIndex];\n              if (!hash) {\n                hash = textToHash(headingText, headingHashesFallbackTranslated);\n              }\n            }\n\n            // enable splitting of long words from function name + first arg name\n            // Closing parens are less interesting since this would only allow breaking one character earlier.\n            // Applying the same mechanism would also allow breaking of non-function signatures like \"Community help (free)\".\n            // To detect that we enabled breaking of open/closing parens we'd need a context-sensitive parser.\n            const displayText = headingText.replace(/([^\\s]\\()/g, '$1&#8203;');\n\n            // create a nested structure with 2 levels starting with level 2 e.g.\n            // [{...level2, children: [level3, level3, level3]}, level2]\n            if (level === 2) {\n              toc.push({\n                text: displayText,\n                level,\n                hash,\n                children: [],\n              });\n            } else if (level === 3) {\n              if (!toc[toc.length - 1]) {\n                throw new Error(`Missing parent level for: ${headingText}`);\n              }\n\n              toc[toc.length - 1].children.push({\n                text: displayText,\n                level,\n                hash,\n              });\n            }\n\n            return [\n              `<h${level}>`,\n              `<a class=\"anchor-link\" id=\"${hash}\"></a>`,\n              headingHtml,\n              `<a class=\"anchor-link-style\" aria-hidden=\"true\" aria-label=\"anchor\" href=\"#${hash}\">`,\n              '<svg><use xlink:href=\"#anchor-link-icon\" /></svg>',\n              '</a>',\n              `</h${level}>`,\n            ].join('');\n          },\n          link: (href, linkTitle, linkText) => {\n            let more = '';\n\n            if (externs.some((domain) => href.indexOf(domain) !== -1)) {\n              more = ' target=\"_blank\" rel=\"noopener nofollow\"';\n            }\n\n            let finalHref = href;\n\n            if (\n              userLanguage !== 'en' &&\n              finalHref.indexOf('/') === 0 &&\n              finalHref !== '/size-snapshot'\n            ) {\n              finalHref = `/${userLanguage}${finalHref}`;\n            }\n\n            return `<a href=\"${finalHref}\"${more}>${linkText}</a>`;\n          },\n        });\n      });\n\n      // fragment link symbol\n      rendered.unshift(`<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n  <symbol id=\"anchor-link-icon\" viewBox=\"0 0 16 16\">\n    <path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\" />\n  </symbol>\n</svg>`);\n\n      docs[userLanguage] = {\n        description,\n        location: headers.filename || `/docs/src/pages/${pageFilename}/${filename}`,\n        rendered,\n        toc,\n        title,\n      };\n    } else if (filename.indexOf('.tsx') !== -1) {\n      const demoName = `pages/${pageFilename}/${filename\n        .replace(/\\.\\//g, '')\n        .replace(/\\.tsx/g, '.js')}`;\n\n      demos[demoName] = {\n        ...demos[demoName],\n        moduleTS: filename,\n        rawTS: requireRaw(filename),\n      };\n    } else {\n      const demoName = `pages/${pageFilename}/${filename.replace(/\\.\\//g, '')}`;\n\n      demos[demoName] = {\n        ...demos[demoName],\n        module: filename,\n        raw: requireRaw(filename),\n      };\n    }\n  });\n\n  return { demos, docs };\n}\n"]},"metadata":{},"sourceType":"module"}