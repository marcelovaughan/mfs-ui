{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread2\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport marked from 'marked/lib/marked';\nimport { LANGUAGES_IN_PROGRESS } from \"../constants\";\nimport kebabCase from 'lodash/kebabCase';\nimport { rewriteUrlForNextExport } from 'next/dist/next-server/lib/router/rewrite-url-for-export';\nimport textToHash from \"./textToHash\";\nimport prism from \"./prism\";\nvar headerRegExp = /---[\\r\\n]([\\s\\S]*)[\\r\\n]---/;\nvar titleRegExp = /# (.*)[\\r\\n]/;\nvar descriptionRegExp = /<p class=\"description\">(.*)<\\/p>[\\r\\n]/;\nvar headerKeyValueRegExp = /(.*): (.*)/g;\nvar emptyRegExp = /^\\s*$/;\nvar notEnglishMarkdownRegExp = /-([a-z]{2})\\.md$/;\n/**\n * Extract information from the top of the markdown.\n * For instance, the following input:\n *\n * ---\n * title: Backdrop React Component\n * components: Backdrop\n * ---\n *\n * # Backdrop\n *\n * should output:\n * { title: 'Backdrop React Component', components: ['Backdrop'] }\n */\n\nexport function getHeaders(markdown) {\n  var header = markdown.match(headerRegExp);\n\n  if (!header) {\n    return {\n      components: []\n    };\n  }\n\n  header = header[1];\n  var regexMatches;\n  var headers = {}; // eslint-disable-next-line no-cond-assign\n\n  while ((regexMatches = headerKeyValueRegExp.exec(header)) !== null) {\n    headers[regexMatches[1]] = regexMatches[2];\n  }\n\n  if (headers.components) {\n    headers.components = headers.components.split(',').map(function (x) {\n      return x.trim();\n    }).sort();\n  } else {\n    headers.components = [];\n  }\n\n  return headers;\n}\nexport var demoRegexp = /^\"demo\": \"(.*)\"/;\nexport function getContents(markdown) {\n  return markdown.replace(headerRegExp, '') // Remove header information\n  .split(/^{{(\"demo\":[^}]*)}}$/gm) // Split markdown into an array, separating demos\n  .filter(function (content) {\n    return !emptyRegExp.test(content);\n  }); // Remove empty lines\n}\nexport function getTitle(markdown) {\n  var matches = markdown.match(titleRegExp);\n\n  if (!matches || !matches[1]) {\n    throw new Error('Missing title in the page');\n  }\n\n  return matches[1];\n}\nexport function getDescription(markdown) {\n  var matches = markdown.match(descriptionRegExp);\n  return matches === null || matches === void 0 ? void 0 : matches[1];\n}\n/**\n * Render markdown used in the Material-UI docs\n *\n * @param {string} markdown\n * @param {object} [options]\n * @param {function} [options.highlight] - https://marked.js.org/#/USING_ADVANCED.md#highlight\n * @param {object} [options.rest] - properties from https://marked.js.org/#/USING_PRO.md#renderer\n */\n\nexport function render(markdown) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var highlight = options.highlight,\n      rendererOptions = _objectWithoutProperties(options, [\"highlight\"]);\n\n  var renderer = _extends(new marked.Renderer(), rendererOptions);\n\n  var markedOptions = {\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: false,\n    smartLists: true,\n    smartypants: false,\n    highlight: highlight,\n    renderer: renderer\n  };\n  return marked(markdown, markedOptions);\n}\nvar externs = ['https://material.io/', 'https://getbootstrap.com/', 'https://www.amazon.com/', 'https://materialdesignicons.com/', 'https://www.w3.org/', 'https://devexpress.github.io/', 'https://ui-kit.co/'];\n/**\n *\n * @param {object} config\n * @param {() => string} config.requireRaw - returnvalue of require.context\n * @param {string} config.pageFilename - filename relative to nextjs pages directory\n */\n\nexport function prepareMarkdown(config) {\n  var pageFilename = config.pageFilename,\n      requireRaw = config.requireRaw;\n  var demos = {};\n  var docs = {};\n  var headingHashes = {}; // Process the English markdown before the other locales.\n\n  var filenames = [];\n  requireRaw.keys().forEach(function (filename) {\n    if (filename.match(notEnglishMarkdownRegExp)) {\n      filenames.push(filename);\n    } else {\n      filenames = [filename].concat(filenames);\n    }\n  });\n  filenames.forEach(function (filename) {\n    if (filename.indexOf('.md') !== -1) {\n      var matchNotEnglishMarkdown = filename.match(notEnglishMarkdownRegExp);\n      var userLanguage = matchNotEnglishMarkdown && LANGUAGES_IN_PROGRESS.indexOf(matchNotEnglishMarkdown[1]) !== -1 ? matchNotEnglishMarkdown[1] : 'en';\n      var markdown = requireRaw(filename);\n      var headers = getHeaders(markdown);\n      var title = headers.title || getTitle(markdown);\n      var description = headers.description || getDescription(markdown);\n      var contents = getContents(markdown);\n\n      if (headers.components.length > 0) {\n        contents.push(\"\\n## API\\n\\n\".concat(headers.components.map(function (component) {\n          return \"- [`<\".concat(component, \" />`](\").concat(rewriteUrlForNextExport(\"/api/\".concat(kebabCase(component))), \")\");\n        }).join('\\n'), \"\\n  \"));\n      }\n\n      var toc = [];\n      var headingHashesFallbackTranslated = {};\n      var headingIndex = -1;\n      var rendered = contents.map(function (content) {\n        if (demos && demoRegexp.test(content)) {\n          try {\n            return JSON.parse(\"{\".concat(content, \"}\"));\n          } catch (err) {\n            console.error('JSON.parse fails with: ', \"{\".concat(content, \"}\"));\n            console.error(err);\n            return null;\n          }\n        }\n\n        return render(content, {\n          highlight: prism,\n          heading: function heading(headingHtml, level) {\n            // Small title. No need for an anchor.\n            // It's reducing the risk of duplicated id and it's fewer elements in the DOM.\n            if (level >= 4) {\n              return \"<h\".concat(level, \">\").concat(headingHtml, \"</h\").concat(level, \">\");\n            }\n\n            var headingText = headingHtml.replace(/([\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])\\uFE0F?/g, '') // remove emojis\n            .replace(/<\\/?[^>]+(>|$)/g, '') // remove HTML\n            .trim(); // Standardizes the hash from the default location (en) to different locations\n            // Need english.md file parsed first\n\n            var hash;\n\n            if (userLanguage === 'en') {\n              hash = textToHash(headingText, headingHashes);\n            } else {\n              headingIndex += 1;\n              hash = _Object$keys(headingHashes)[headingIndex];\n\n              if (!hash) {\n                hash = textToHash(headingText, headingHashesFallbackTranslated);\n              }\n            } // enable splitting of long words from function name + first arg name\n            // Closing parens are less interesting since this would only allow breaking one character earlier.\n            // Applying the same mechanism would also allow breaking of non-function signatures like \"Community help (free)\".\n            // To detect that we enabled breaking of open/closing parens we'd need a context-sensitive parser.\n\n\n            var displayText = headingText.replace(/([^\\s]\\()/g, '$1&#8203;'); // create a nested structure with 2 levels starting with level 2 e.g.\n            // [{...level2, children: [level3, level3, level3]}, level2]\n\n            if (level === 2) {\n              toc.push({\n                text: displayText,\n                level: level,\n                hash: hash,\n                children: []\n              });\n            } else if (level === 3) {\n              if (!toc[toc.length - 1]) {\n                throw new Error(\"Missing parent level for: \".concat(headingText));\n              }\n\n              toc[toc.length - 1].children.push({\n                text: displayText,\n                level: level,\n                hash: hash\n              });\n            }\n\n            return [\"<h\".concat(level, \">\"), \"<a class=\\\"anchor-link\\\" id=\\\"\".concat(hash, \"\\\"></a>\"), headingHtml, \"<a class=\\\"anchor-link-style\\\" aria-hidden=\\\"true\\\" aria-label=\\\"anchor\\\" href=\\\"#\".concat(hash, \"\\\">\"), '<svg><use xlink:href=\"#anchor-link-icon\" /></svg>', '</a>', \"</h\".concat(level, \">\")].join('');\n          },\n          link: function link(href, linkTitle, linkText) {\n            var more = '';\n\n            if (externs.some(function (domain) {\n              return href.indexOf(domain) !== -1;\n            })) {\n              more = ' target=\"_blank\" rel=\"noopener nofollow\"';\n            }\n\n            var finalHref = href;\n\n            if (userLanguage !== 'en' && finalHref.indexOf('/') === 0 && finalHref !== '/size-snapshot') {\n              finalHref = \"/\".concat(userLanguage).concat(finalHref);\n            }\n\n            return \"<a href=\\\"\".concat(finalHref, \"\\\"\").concat(more, \">\").concat(linkText, \"</a>\");\n          }\n        });\n      }); // fragment link symbol\n\n      rendered.unshift(\"<svg style=\\\"display: none;\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <symbol id=\\\"anchor-link-icon\\\" viewBox=\\\"0 0 16 16\\\">\\n    <path d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\" />\\n  </symbol>\\n</svg>\");\n      docs[userLanguage] = {\n        description: description,\n        location: headers.filename || \"/docs/src/pages/\".concat(pageFilename, \"/\").concat(filename),\n        rendered: rendered,\n        toc: toc,\n        title: title\n      };\n    } else if (filename.indexOf('.tsx') !== -1) {\n      var demoName = \"pages/\".concat(pageFilename, \"/\").concat(filename.replace(/\\.\\//g, '').replace(/\\.tsx/g, '.js'));\n      demos[demoName] = _objectSpread(_objectSpread({}, demos[demoName]), {}, {\n        moduleTS: filename,\n        rawTS: requireRaw(filename)\n      });\n    } else {\n      var _demoName = \"pages/\".concat(pageFilename, \"/\").concat(filename.replace(/\\.\\//g, ''));\n\n      demos[_demoName] = _objectSpread(_objectSpread({}, demos[_demoName]), {}, {\n        module: filename,\n        raw: requireRaw(filename)\n      });\n    }\n  });\n  return {\n    demos: demos,\n    docs: docs\n  };\n}","map":null,"metadata":{},"sourceType":"module"}