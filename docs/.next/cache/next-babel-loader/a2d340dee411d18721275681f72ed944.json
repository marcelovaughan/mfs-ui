{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport { withStyles } from \"../../../material-ui/src/styles\";\nimport { useControlled } from \"../../../material-ui/src/utils\";\nimport TreeViewContext from \"./TreeViewContext\";\nexport const styles = {\n  /* Styles applied to the root element. */\n  root: {\n    padding: 0,\n    margin: 0,\n    listStyle: 'none'\n  }\n};\n\nfunction arrayDiff(arr1, arr2) {\n  if (arr1.length !== arr2.length) return true;\n\n  for (let i = 0; i < arr1.length; i += 1) {\n    if (arr1[i] !== arr2[i]) return true;\n  }\n\n  return false;\n}\n\nconst findNextFirstChar = (firstChars, startIndex, char) => {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nconst defaultExpandedDefault = [];\nconst defaultSelectedDefault = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(props, ref) {\n  const {\n    children,\n    classes,\n    className,\n    defaultCollapseIcon,\n    defaultEndIcon,\n    defaultExpanded = defaultExpandedDefault,\n    defaultExpandIcon,\n    defaultParentIcon,\n    defaultSelected = defaultSelectedDefault,\n    disableSelection = false,\n    multiSelect = false,\n    expanded: expandedProp,\n    onNodeSelect,\n    onNodeToggle,\n    selected: selectedProp\n  } = props,\n        other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disableSelection\", \"multiSelect\", \"expanded\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"]);\n\n  const [tabbable, setTabbable] = React.useState(null);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const visibleNodes = React.useRef([]);\n  const [expanded, setExpandedState] = useControlled({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = useControlled({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n  /*\n   * Status Helpers\n   */\n\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n\n  const isTabbable = id => tabbable === id;\n\n  const isFocused = id => focusedNodeId === id;\n  /*\n   * Node Helpers\n   */\n\n\n  const getNextNode = id => {\n    const nodeIndex = visibleNodes.current.indexOf(id);\n\n    if (nodeIndex !== -1 && nodeIndex + 1 < visibleNodes.current.length) {\n      return visibleNodes.current[nodeIndex + 1];\n    }\n\n    return null;\n  };\n\n  const getPreviousNode = id => {\n    const nodeIndex = visibleNodes.current.indexOf(id);\n\n    if (nodeIndex !== -1 && nodeIndex - 1 >= 0) {\n      return visibleNodes.current[nodeIndex - 1];\n    }\n\n    return null;\n  };\n\n  const getLastNode = () => visibleNodes.current[visibleNodes.current.length - 1];\n\n  const getFirstNode = () => visibleNodes.current[0];\n\n  const getParent = id => nodeMap.current[id].parent;\n\n  const getNodesInRange = (a, b) => {\n    const aIndex = visibleNodes.current.indexOf(a);\n    const bIndex = visibleNodes.current.indexOf(b);\n    const start = Math.min(aIndex, bIndex);\n    const end = Math.max(aIndex, bIndex);\n    return visibleNodes.current.slice(start, end + 1);\n  };\n  /*\n   * Focus Helpers\n   */\n\n\n  const focus = id => {\n    if (id) {\n      setTabbable(id);\n      setFocusedNodeId(id);\n    }\n  };\n\n  const focusNextNode = id => focus(getNextNode(id));\n\n  const focusPreviousNode = id => focus(getPreviousNode(id));\n\n  const focusFirstNode = () => focus(getFirstNode());\n\n  const focusLastNode = () => focus(getLastNode());\n\n  const focusByFirstCharacter = (id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = []; // This really only works since the ids are strings\n\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parent ? isExpanded(map.parent) : true;\n\n      if (visible) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    }); // Get start index for search based on position of currentItem\n\n    start = firstCharIds.indexOf(id) + 1;\n\n    if (start === nodeMap.current.length) {\n      start = 0;\n    } // Check remaining slots in the menu\n\n\n    index = findNextFirstChar(firstChars, start, lowercaseChar); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    } // If match was found...\n\n\n    if (index > -1) {\n      focus(firstCharIds[index]);\n    }\n  };\n  /*\n   * Expansion Helpers\n   */\n\n\n  const toggleExpansion = (event, value = focusedNodeId) => {\n    let newExpanded;\n\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n      setTabbable(oldTabbable => {\n        const map = nodeMap.current[oldTabbable];\n\n        if (oldTabbable && (map && map.parent ? map.parent.id : null) === value) {\n          return value;\n        }\n\n        return oldTabbable;\n      });\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n\n    setExpandedState(newExpanded);\n  };\n\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const parent = nodeMap.current[map.parent];\n    let diff;\n\n    if (parent) {\n      diff = parent.children.filter(child => !isExpanded(child));\n    } else {\n      const topLevelNodes = nodeMap.current[-1].children;\n      diff = topLevelNodes.filter(node => !isExpanded(node));\n    }\n\n    const newExpanded = expanded.concat(diff);\n\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n  /*\n   * Selection Helpers\n   */\n\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected;\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n\n    if (!next || !current) {\n      return;\n    }\n\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n\n    setSelectedState(base);\n  };\n\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected;\n    const {\n      start,\n      end\n    } = nodes; // If last selection was a range selection ignore nodes that were selected.\n\n    if (lastSelectionWasRange.current) {\n      base = selected.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n\n    const range = getNodesInRange(start, end);\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleMultipleSelect = (event, value) => {\n    let newSelected = [];\n\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const selectNode = (event, id, multiple = false) => {\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n\n    return false;\n  };\n\n  const selectRange = (event, nodes, stacked = false) => {\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n\n    lastSelectionWasRange.current = true;\n    return true;\n  };\n\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    return selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    return selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n\n  const selectNextNode = (event, id) => selectRange(event, {\n    end: getNextNode(id),\n    current: id\n  }, true);\n\n  const selectPreviousNode = (event, id) => selectRange(event, {\n    end: getPreviousNode(id),\n    current: id\n  }, true);\n\n  const selectAllNodes = event => selectRange(event, {\n    start: getFirstNode(),\n    end: getLastNode()\n  });\n  /*\n   * Mapping Helpers\n   */\n\n\n  const addNodeToNodeMap = (id, childrenIds) => {\n    const currentMap = nodeMap.current[id];\n    nodeMap.current[id] = _objectSpread(_objectSpread({}, currentMap), {}, {\n      children: childrenIds,\n      id\n    });\n    childrenIds.forEach(childId => {\n      const currentChildMap = nodeMap.current[childId];\n      nodeMap.current[childId] = _objectSpread(_objectSpread({}, currentChildMap), {}, {\n        parent: id,\n        id: childId\n      });\n    });\n  };\n\n  const getNodesToRemove = React.useCallback(id => {\n    const map = nodeMap.current[id];\n    const nodes = [];\n\n    if (map) {\n      nodes.push(id);\n\n      if (map.children) {\n        nodes.concat(map.children);\n        map.children.forEach(node => {\n          nodes.concat(getNodesToRemove(node));\n        });\n      }\n    }\n\n    return nodes;\n  }, []);\n  const cleanUpFirstCharMap = React.useCallback(nodes => {\n    const newMap = _objectSpread({}, firstCharMap.current);\n\n    nodes.forEach(node => {\n      if (newMap[node]) {\n        delete newMap[node];\n      }\n    });\n    firstCharMap.current = newMap;\n  }, []);\n  const removeNodeFromNodeMap = React.useCallback(id => {\n    const nodes = getNodesToRemove(id);\n    cleanUpFirstCharMap(nodes);\n\n    const newMap = _objectSpread({}, nodeMap.current);\n\n    nodes.forEach(node => {\n      const map = newMap[node];\n\n      if (map) {\n        if (map.parent) {\n          const parentMap = newMap[map.parent];\n\n          if (parentMap && parentMap.children) {\n            const parentChildren = parentMap.children.filter(c => c !== node);\n            newMap[map.parent] = _objectSpread(_objectSpread({}, parentMap), {}, {\n              children: parentChildren\n            });\n          }\n        }\n\n        delete newMap[node];\n      }\n    });\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id) {\n        return null;\n      }\n\n      return oldFocusedNodeId;\n    });\n  }, [getNodesToRemove, cleanUpFirstCharMap]);\n\n  const mapFirstChar = (id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  };\n\n  const prevChildIds = React.useRef([]);\n  const [childrenCalculated, setChildrenCalculated] = React.useState(false);\n  React.useEffect(() => {\n    const childIds = [];\n    React.Children.forEach(children, child => {\n      if ( /*#__PURE__*/React.isValidElement(child) && child.props.nodeId) {\n        childIds.push(child.props.nodeId);\n      }\n    });\n\n    if (arrayDiff(prevChildIds.current, childIds)) {\n      nodeMap.current[-1] = {\n        parent: null,\n        children: childIds\n      };\n      childIds.forEach((id, index) => {\n        if (index === 0) {\n          setTabbable(id);\n        }\n      });\n      visibleNodes.current = nodeMap.current[-1].children;\n      prevChildIds.current = childIds;\n      setChildrenCalculated(true);\n    }\n  }, [children]);\n  React.useEffect(() => {\n    const buildVisible = nodes => {\n      let list = [];\n\n      for (let i = 0; i < nodes.length; i += 1) {\n        const item = nodes[i];\n        list.push(item);\n        const childs = nodeMap.current[item].children;\n\n        if (isExpanded(item) && childs) {\n          list = list.concat(buildVisible(childs));\n        }\n      }\n\n      return list;\n    };\n\n    if (childrenCalculated) {\n      visibleNodes.current = buildVisible(nodeMap.current[-1].children);\n    }\n  }, [expanded, childrenCalculated, isExpanded, children]);\n\n  const noopSelection = () => {\n    return false;\n  };\n\n  return __jsx(TreeViewContext.Provider, {\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      focusFirstNode,\n      focusLastNode,\n      focusNextNode,\n      focusPreviousNode,\n      focusByFirstCharacter,\n      expandAllSiblings,\n      toggleExpansion,\n      isExpanded,\n      isFocused,\n      isSelected,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      selectNextNode: disableSelection ? noopSelection : selectNextNode,\n      selectPreviousNode: disableSelection ? noopSelection : selectPreviousNode,\n      rangeSelectToFirst: disableSelection ? noopSelection : rangeSelectToFirst,\n      rangeSelectToLast: disableSelection ? noopSelection : rangeSelectToLast,\n      selectAllNodes: disableSelection ? noopSelection : selectAllNodes,\n      isTabbable,\n      multiSelect,\n      getParent,\n      mapFirstChar,\n      addNodeToNodeMap,\n      removeNodeFromNodeMap\n    }\n  }, __jsx(\"ul\", _extends({\n    role: \"tree\",\n    \"aria-multiselectable\": multiSelect,\n    className: clsx(classes.root, className),\n    ref: ref\n  }, other), children));\n});\nexport default withStyles(styles, {\n  name: 'MuiTreeView'\n})(TreeView);","map":null,"metadata":{},"sourceType":"module"}