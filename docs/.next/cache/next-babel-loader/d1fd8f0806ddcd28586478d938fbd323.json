{"ast":null,"code":"var _jsxFileName = \"/home/marcelo.faria/Documentos/b2w/msf-ui/packages/material-ui/src/Menu/Menu.js\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { HTMLElementType } from \"../../../material-ui-utils/src\";\nimport withStyles from \"../styles/withStyles\";\nimport Popover from \"../Popover\";\nimport MenuList from \"../MenuList\";\nimport * as ReactDOM from 'react-dom';\nimport setRef from \"../utils/setRef\";\nimport useTheme from \"../styles/useTheme\";\nconst RTL_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'right'\n};\nconst LTR_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'left'\n};\nexport const styles = {\n  /* Styles applied to the `Paper` component. */\n  paper: {\n    // specZ: The maximum height of a simple menu should be one or more rows less than the view\n    // height. This ensures a tapable area outside of the simple menu with which to dismiss\n    // the menu.\n    maxHeight: 'calc(100% - 96px)',\n    // Add iOS momentum scrolling.\n    WebkitOverflowScrolling: 'touch'\n  },\n\n  /* Styles applied to the `List` component via `MenuList`. */\n  list: {\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0\n  }\n};\nconst Menu = /*#__PURE__*/React.forwardRef(function Menu(props, ref) {\n  const {\n    autoFocus = true,\n    children,\n    classes,\n    disableAutoFocusItem = false,\n    MenuListProps = {},\n    onClose,\n    onEntering,\n    open,\n    PaperProps = {},\n    PopoverClasses,\n    transitionDuration = 'auto',\n    variant = 'selectedMenu'\n  } = props,\n        other = _objectWithoutProperties(props, [\"autoFocus\", \"children\", \"classes\", \"disableAutoFocusItem\", \"MenuListProps\", \"onClose\", \"onEntering\", \"open\", \"PaperProps\", \"PopoverClasses\", \"transitionDuration\", \"variant\"]);\n\n  const theme = useTheme();\n  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;\n  const menuListActionsRef = React.useRef(null);\n  const contentAnchorRef = React.useRef(null);\n\n  const getContentAnchorEl = () => contentAnchorRef.current;\n\n  const handleEntering = (element, isAppearing) => {\n    if (menuListActionsRef.current) {\n      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);\n    }\n\n    if (onEntering) {\n      onEntering(element, isAppearing);\n    }\n  };\n\n  const handleListKeyDown = event => {\n    if (event.key === 'Tab') {\n      event.preventDefault();\n\n      if (onClose) {\n        onClose(event, 'tabKeyDown');\n      }\n    }\n  };\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n\n\n  let activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n\n  React.Children.map(children, (child, index) => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      return;\n    }\n\n    if (true) {\n      if (isFragment(child)) {\n        console.error([\"Material-UI: The Menu component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n\n    if (!child.props.disabled) {\n      if (variant !== \"menu\" && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n  });\n  const items = React.Children.map(children, (child, index) => {\n    if (index === activeItemIndex) {\n      return /*#__PURE__*/React.cloneElement(child, {\n        ref: instance => {\n          // #StrictMode ready\n          contentAnchorRef.current = ReactDOM.findDOMNode(instance);\n          setRef(child.ref, instance);\n        }\n      });\n    }\n\n    return child;\n  });\n  return __jsx(Popover, _extends({\n    getContentAnchorEl: getContentAnchorEl,\n    classes: PopoverClasses,\n    onClose: onClose,\n    onEntering: handleEntering,\n    anchorOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,\n    transformOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,\n    PaperProps: _objectSpread(_objectSpread({}, PaperProps), {}, {\n      classes: _objectSpread(_objectSpread({}, PaperProps.classes), {}, {\n        root: classes.paper\n      })\n    }),\n    open: open,\n    ref: ref,\n    transitionDuration: transitionDuration\n  }, other, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 5\n    }\n  }), __jsx(MenuList, _extends({\n    \"data-mui-test\": \"Menu\",\n    onKeyDown: handleListKeyDown,\n    actions: menuListActionsRef,\n    autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),\n    autoFocusItem: autoFocusItem,\n    variant: variant\n  }, MenuListProps, {\n    className: clsx(classes.list, MenuListProps.className),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 7\n    }\n  }), items));\n});\nMenu.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * A HTML element, or a function that returns it.\n   * It's used to set the position of the menu.\n   */\n  anchorEl: PropTypes\n  /* @typescript-to-proptypes-ignore */\n  .oneOfType([HTMLElementType, PropTypes.func]),\n\n  /**\n   * If `true` (Default) will focus the `[role=\"menu\"]` if no focusable child is found. Disabled\n   * children are not focusable. If you set this prop to `false` focus will be placed\n   * on the parent modal container. This has severe accessibility implications\n   * and should only be considered if you manage focus otherwise.\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * Menu contents, normally `MenuItem`s.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * When opening the menu will not focus the active item but the `[role=\"menu\"]`\n   * unless `autoFocus` is also set to `false`. Not using the default means not\n   * following WAI-ARIA authoring practices. Please be considerate about possible\n   * accessibility implications.\n   */\n  disableAutoFocusItem: PropTypes.bool,\n\n  /**\n   * Props applied to the [`MenuList`](/api/menu-list/) element.\n   */\n  MenuListProps: PropTypes.object,\n\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {string} reason Can be: `\"escapeKeyDown\"`, `\"backdropClick\"`, `\"tabKeyDown\"`.\n   */\n  onClose: PropTypes.func,\n\n  /**\n   * Callback fired before the Menu enters.\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired when the Menu has entered.\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired when the Menu is entering.\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired before the Menu exits.\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired when the Menu has exited.\n   */\n  onExited: PropTypes.func,\n\n  /**\n   * Callback fired when the Menu is exiting.\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * If `true`, the menu is visible.\n   */\n  open: PropTypes.bool.isRequired,\n\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.object,\n\n  /**\n   * `classes` prop applied to the [`Popover`](/api/popover/) element.\n   */\n  PopoverClasses: PropTypes.object,\n\n  /**\n   * The length of the transition in `ms`, or 'auto'\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({\n    appear: PropTypes.number,\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\n   * and the vertical alignment relative to the anchor element.\n   */\n  variant: PropTypes.oneOf(['menu', 'selectedMenu'])\n};\nexport default withStyles(styles, {\n  name: 'MuiMenu'\n})(Menu);","map":{"version":3,"sources":["/home/marcelo.faria/Documentos/b2w/msf-ui/packages/material-ui/src/Menu/Menu.js"],"names":["React","isFragment","PropTypes","clsx","HTMLElementType","withStyles","Popover","MenuList","ReactDOM","setRef","useTheme","RTL_ORIGIN","vertical","horizontal","LTR_ORIGIN","styles","paper","maxHeight","WebkitOverflowScrolling","list","outline","Menu","forwardRef","props","ref","autoFocus","children","classes","disableAutoFocusItem","MenuListProps","onClose","onEntering","open","PaperProps","PopoverClasses","transitionDuration","variant","other","theme","autoFocusItem","menuListActionsRef","useRef","contentAnchorRef","getContentAnchorEl","current","handleEntering","element","isAppearing","adjustStyleForScrollbar","handleListKeyDown","event","key","preventDefault","activeItemIndex","Children","map","child","index","isValidElement","console","error","join","disabled","selected","items","cloneElement","instance","findDOMNode","direction","root","className","propTypes","anchorEl","oneOfType","func","bool","node","object","onEnter","onEntered","onExit","onExited","onExiting","isRequired","oneOf","number","shape","appear","enter","exit","name"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { HTMLElementType } from '@material-ui/utils';\nimport withStyles from '../styles/withStyles';\nimport Popover from '../Popover';\nimport MenuList from '../MenuList';\nimport * as ReactDOM from 'react-dom';\nimport setRef from '../utils/setRef';\nimport useTheme from '../styles/useTheme';\n\nconst RTL_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'right',\n};\n\nconst LTR_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'left',\n};\n\nexport const styles = {\n  /* Styles applied to the `Paper` component. */\n  paper: {\n    // specZ: The maximum height of a simple menu should be one or more rows less than the view\n    // height. This ensures a tapable area outside of the simple menu with which to dismiss\n    // the menu.\n    maxHeight: 'calc(100% - 96px)',\n    // Add iOS momentum scrolling.\n    WebkitOverflowScrolling: 'touch',\n  },\n  /* Styles applied to the `List` component via `MenuList`. */\n  list: {\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0,\n  },\n};\n\nconst Menu = React.forwardRef(function Menu(props, ref) {\n  const {\n    autoFocus = true,\n    children,\n    classes,\n    disableAutoFocusItem = false,\n    MenuListProps = {},\n    onClose,\n    onEntering,\n    open,\n    PaperProps = {},\n    PopoverClasses,\n    transitionDuration = 'auto',\n    variant = 'selectedMenu',\n    ...other\n  } = props;\n  const theme = useTheme();\n\n  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;\n\n  const menuListActionsRef = React.useRef(null);\n  const contentAnchorRef = React.useRef(null);\n\n  const getContentAnchorEl = () => contentAnchorRef.current;\n\n  const handleEntering = (element, isAppearing) => {\n    if (menuListActionsRef.current) {\n      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);\n    }\n\n    if (onEntering) {\n      onEntering(element, isAppearing);\n    }\n  };\n\n  const handleListKeyDown = (event) => {\n    if (event.key === 'Tab') {\n      event.preventDefault();\n\n      if (onClose) {\n        onClose(event, 'tabKeyDown');\n      }\n    }\n  };\n\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n  let activeItemIndex = -1;\n  // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n  React.Children.map(children, (child, index) => {\n    if (!React.isValidElement(child)) {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error(\n          [\n            \"Material-UI: The Menu component doesn't accept a Fragment as a child.\",\n            'Consider providing an array instead.',\n          ].join('\\n'),\n        );\n      }\n    }\n\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n  });\n\n  const items = React.Children.map(children, (child, index) => {\n    if (index === activeItemIndex) {\n      return React.cloneElement(child, {\n        ref: (instance) => {\n          // #StrictMode ready\n          contentAnchorRef.current = ReactDOM.findDOMNode(instance);\n          setRef(child.ref, instance);\n        },\n      });\n    }\n\n    return child;\n  });\n\n  return (\n    <Popover\n      getContentAnchorEl={getContentAnchorEl}\n      classes={PopoverClasses}\n      onClose={onClose}\n      onEntering={handleEntering}\n      anchorOrigin={theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN}\n      transformOrigin={theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN}\n      PaperProps={{\n        ...PaperProps,\n        classes: {\n          ...PaperProps.classes,\n          root: classes.paper,\n        },\n      }}\n      open={open}\n      ref={ref}\n      transitionDuration={transitionDuration}\n      {...other}\n    >\n      <MenuList\n        data-mui-test=\"Menu\"\n        onKeyDown={handleListKeyDown}\n        actions={menuListActionsRef}\n        autoFocus={autoFocus && (activeItemIndex === -1 || disableAutoFocusItem)}\n        autoFocusItem={autoFocusItem}\n        variant={variant}\n        {...MenuListProps}\n        className={clsx(classes.list, MenuListProps.className)}\n      >\n        {items}\n      </MenuList>\n    </Popover>\n  );\n});\n\nMenu.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * A HTML element, or a function that returns it.\n   * It's used to set the position of the menu.\n   */\n  anchorEl: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([\n    HTMLElementType,\n    PropTypes.func,\n  ]),\n  /**\n   * If `true` (Default) will focus the `[role=\"menu\"]` if no focusable child is found. Disabled\n   * children are not focusable. If you set this prop to `false` focus will be placed\n   * on the parent modal container. This has severe accessibility implications\n   * and should only be considered if you manage focus otherwise.\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * Menu contents, normally `MenuItem`s.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * When opening the menu will not focus the active item but the `[role=\"menu\"]`\n   * unless `autoFocus` is also set to `false`. Not using the default means not\n   * following WAI-ARIA authoring practices. Please be considerate about possible\n   * accessibility implications.\n   */\n  disableAutoFocusItem: PropTypes.bool,\n  /**\n   * Props applied to the [`MenuList`](/api/menu-list/) element.\n   */\n  MenuListProps: PropTypes.object,\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {string} reason Can be: `\"escapeKeyDown\"`, `\"backdropClick\"`, `\"tabKeyDown\"`.\n   */\n  onClose: PropTypes.func,\n  /**\n   * Callback fired before the Menu enters.\n   */\n  onEnter: PropTypes.func,\n  /**\n   * Callback fired when the Menu has entered.\n   */\n  onEntered: PropTypes.func,\n  /**\n   * Callback fired when the Menu is entering.\n   */\n  onEntering: PropTypes.func,\n  /**\n   * Callback fired before the Menu exits.\n   */\n  onExit: PropTypes.func,\n  /**\n   * Callback fired when the Menu has exited.\n   */\n  onExited: PropTypes.func,\n  /**\n   * Callback fired when the Menu is exiting.\n   */\n  onExiting: PropTypes.func,\n  /**\n   * If `true`, the menu is visible.\n   */\n  open: PropTypes.bool.isRequired,\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.object,\n  /**\n   * `classes` prop applied to the [`Popover`](/api/popover/) element.\n   */\n  PopoverClasses: PropTypes.object,\n  /**\n   * The length of the transition in `ms`, or 'auto'\n   */\n  transitionDuration: PropTypes.oneOfType([\n    PropTypes.oneOf(['auto']),\n    PropTypes.number,\n    PropTypes.shape({\n      appear: PropTypes.number,\n      enter: PropTypes.number,\n      exit: PropTypes.number,\n    }),\n  ]),\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\n   * and the vertical alignment relative to the anchor element.\n   */\n  variant: PropTypes.oneOf(['menu', 'selectedMenu']),\n};\n\nexport default withStyles(styles, { name: 'MuiMenu' })(Menu);\n"]},"metadata":{},"sourceType":"module"}