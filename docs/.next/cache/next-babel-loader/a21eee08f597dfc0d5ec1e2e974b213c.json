{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n// Sorted ASC by size. That's important.\n// It can't be configured as it's used statically for propTypes.\nexport const keys = ['xs', 'sm', 'md', 'lg', 'xl']; // Keep in mind that @media is inclusive by the CSS specification.\n\nexport default function createBreakpoints(breakpoints) {\n  const {\n    // The breakpoint **start** at this value.\n    // For instance with the first breakpoint xs: [xs, sm[.\n    values = {\n      xs: 0,\n      sm: 600,\n      md: 960,\n      lg: 1280,\n      xl: 1920\n    },\n    unit = 'px',\n    step = 5\n  } = breakpoints,\n        other = _objectWithoutProperties(breakpoints, [\"values\", \"unit\", \"step\"]);\n\n  function up(key) {\n    const value = typeof values[key] === 'number' ? values[key] : key;\n    return `@media (min-width:${value}${unit})`;\n  }\n\n  function down(key) {\n    const endIndex = keys.indexOf(key) + 1;\n    const upperbound = values[keys[endIndex]];\n\n    if (endIndex === keys.length) {\n      // xl down applies to all sizes\n      return up('xs');\n    }\n\n    const value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;\n    return `@media (max-width:${value - step / 100}${unit})`;\n  }\n\n  function between(start, end) {\n    const endIndex = keys.indexOf(end);\n\n    if (endIndex === keys.length - 1) {\n      return up(start);\n    }\n\n    return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex + 1]] === 'number' ? values[keys[endIndex + 1]] : end) - step / 100}${unit})`;\n  }\n\n  function only(key) {\n    return between(key, key);\n  }\n\n  function width(key) {\n    return values[key];\n  }\n\n  return _objectSpread({\n    keys,\n    values,\n    up,\n    down,\n    between,\n    only,\n    width\n  }, other);\n}","map":{"version":3,"sources":["/home/marcelo.faria/Documentos/b2w/msf-ui/packages/material-ui/src/styles/createBreakpoints.js"],"names":["keys","createBreakpoints","breakpoints","values","xs","sm","md","lg","xl","unit","step","other","up","key","value","down","endIndex","indexOf","upperbound","length","between","start","end","only","width"],"mappings":";;;;;;;;;;AAAA;AACA;AACA,OAAO,MAAMA,IAAI,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,CAAb,C,CAEP;;AACA,eAAe,SAASC,iBAAT,CAA2BC,WAA3B,EAAwC;AACrD,QAAM;AACJ;AACA;AACAC,IAAAA,MAAM,GAAG;AACPC,MAAAA,EAAE,EAAE,CADG;AAEPC,MAAAA,EAAE,EAAE,GAFG;AAGPC,MAAAA,EAAE,EAAE,GAHG;AAIPC,MAAAA,EAAE,EAAE,IAJG;AAKPC,MAAAA,EAAE,EAAE;AALG,KAHL;AAUJC,IAAAA,IAAI,GAAG,IAVH;AAWJC,IAAAA,IAAI,GAAG;AAXH,MAaFR,WAbJ;AAAA,QAYKS,KAZL,4BAaIT,WAbJ;;AAeA,WAASU,EAAT,CAAYC,GAAZ,EAAiB;AACf,UAAMC,KAAK,GAAG,OAAOX,MAAM,CAACU,GAAD,CAAb,KAAuB,QAAvB,GAAkCV,MAAM,CAACU,GAAD,CAAxC,GAAgDA,GAA9D;AACA,WAAQ,qBAAoBC,KAAM,GAAEL,IAAK,GAAzC;AACD;;AAED,WAASM,IAAT,CAAcF,GAAd,EAAmB;AACjB,UAAMG,QAAQ,GAAGhB,IAAI,CAACiB,OAAL,CAAaJ,GAAb,IAAoB,CAArC;AACA,UAAMK,UAAU,GAAGf,MAAM,CAACH,IAAI,CAACgB,QAAD,CAAL,CAAzB;;AAEA,QAAIA,QAAQ,KAAKhB,IAAI,CAACmB,MAAtB,EAA8B;AAC5B;AACA,aAAOP,EAAE,CAAC,IAAD,CAAT;AACD;;AAED,UAAME,KAAK,GAAG,OAAOI,UAAP,KAAsB,QAAtB,IAAkCF,QAAQ,GAAG,CAA7C,GAAiDE,UAAjD,GAA8DL,GAA5E;AACA,WAAQ,qBAAoBC,KAAK,GAAGJ,IAAI,GAAG,GAAI,GAAED,IAAK,GAAtD;AACD;;AAED,WAASW,OAAT,CAAiBC,KAAjB,EAAwBC,GAAxB,EAA6B;AAC3B,UAAMN,QAAQ,GAAGhB,IAAI,CAACiB,OAAL,CAAaK,GAAb,CAAjB;;AAEA,QAAIN,QAAQ,KAAKhB,IAAI,CAACmB,MAAL,GAAc,CAA/B,EAAkC;AAChC,aAAOP,EAAE,CAACS,KAAD,CAAT;AACD;;AAED,WACG,qBACC,OAAOlB,MAAM,CAACkB,KAAD,CAAb,KAAyB,QAAzB,GAAoClB,MAAM,CAACkB,KAAD,CAA1C,GAAoDA,KACrD,GAAEZ,IAAK,QAFR,GAGC,cACC,CAACO,QAAQ,KAAK,CAAC,CAAd,IAAmB,OAAOb,MAAM,CAACH,IAAI,CAACgB,QAAQ,GAAG,CAAZ,CAAL,CAAb,KAAsC,QAAzD,GACGb,MAAM,CAACH,IAAI,CAACgB,QAAQ,GAAG,CAAZ,CAAL,CADT,GAEGM,GAFJ,IAGAZ,IAAI,GAAG,GACR,GAAED,IAAK,GATV;AAWD;;AAED,WAASc,IAAT,CAAcV,GAAd,EAAmB;AACjB,WAAOO,OAAO,CAACP,GAAD,EAAMA,GAAN,CAAd;AACD;;AAED,WAASW,KAAT,CAAeX,GAAf,EAAoB;AAClB,WAAOV,MAAM,CAACU,GAAD,CAAb;AACD;;AAED;AACEb,IAAAA,IADF;AAEEG,IAAAA,MAFF;AAGES,IAAAA,EAHF;AAIEG,IAAAA,IAJF;AAKEK,IAAAA,OALF;AAMEG,IAAAA,IANF;AAOEC,IAAAA;AAPF,KAQKb,KARL;AAUD","sourcesContent":["// Sorted ASC by size. That's important.\n// It can't be configured as it's used statically for propTypes.\nexport const keys = ['xs', 'sm', 'md', 'lg', 'xl'];\n\n// Keep in mind that @media is inclusive by the CSS specification.\nexport default function createBreakpoints(breakpoints) {\n  const {\n    // The breakpoint **start** at this value.\n    // For instance with the first breakpoint xs: [xs, sm[.\n    values = {\n      xs: 0,\n      sm: 600,\n      md: 960,\n      lg: 1280,\n      xl: 1920,\n    },\n    unit = 'px',\n    step = 5,\n    ...other\n  } = breakpoints;\n\n  function up(key) {\n    const value = typeof values[key] === 'number' ? values[key] : key;\n    return `@media (min-width:${value}${unit})`;\n  }\n\n  function down(key) {\n    const endIndex = keys.indexOf(key) + 1;\n    const upperbound = values[keys[endIndex]];\n\n    if (endIndex === keys.length) {\n      // xl down applies to all sizes\n      return up('xs');\n    }\n\n    const value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;\n    return `@media (max-width:${value - step / 100}${unit})`;\n  }\n\n  function between(start, end) {\n    const endIndex = keys.indexOf(end);\n\n    if (endIndex === keys.length - 1) {\n      return up(start);\n    }\n\n    return (\n      `@media (min-width:${\n        typeof values[start] === 'number' ? values[start] : start\n      }${unit}) and ` +\n      `(max-width:${\n        (endIndex !== -1 && typeof values[keys[endIndex + 1]] === 'number'\n          ? values[keys[endIndex + 1]]\n          : end) -\n        step / 100\n      }${unit})`\n    );\n  }\n\n  function only(key) {\n    return between(key, key);\n  }\n\n  function width(key) {\n    return values[key];\n  }\n\n  return {\n    keys,\n    values,\n    up,\n    down,\n    between,\n    only,\n    width,\n    ...other,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}