{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport Modal from \"../Modal\";\nimport Backdrop from \"../Backdrop\";\nimport withStyles from \"../styles/withStyles\";\nimport Slide from \"../Slide\";\nimport Paper from \"../Paper\";\nimport capitalize from \"../utils/capitalize\";\nimport { duration } from \"../styles/transitions\";\nimport useTheme from \"../styles/useTheme\";\nexport const styles = theme => ({\n  /* Styles applied to the root element. */\n  root: {},\n\n  /* Styles applied to the root element if `variant=\"permanent or persistent\"`. */\n  docked: {\n    flex: '0 0 auto'\n  },\n\n  /* Styles applied to the `Paper` component. */\n  paper: {\n    overflowY: 'auto',\n    display: 'flex',\n    flexDirection: 'column',\n    height: '100%',\n    flex: '1 0 auto',\n    zIndex: theme.zIndex.drawer,\n    WebkitOverflowScrolling: 'touch',\n    // Add iOS momentum scrolling.\n    // temporary style\n    position: 'fixed',\n    top: 0,\n    // We disable the focus ring for mouse, touch and keyboard users.\n    // At some point, it would be better to keep it for keyboard users.\n    // :focus-ring CSS pseudo-class will help.\n    outline: 0\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"left\"`. */\n  paperAnchorLeft: {\n    left: 0,\n    right: 'auto'\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"right\"`. */\n  paperAnchorRight: {\n    left: 'auto',\n    right: 0\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"top\"`. */\n  paperAnchorTop: {\n    top: 0,\n    left: 0,\n    bottom: 'auto',\n    right: 0,\n    height: 'auto',\n    maxHeight: '100%'\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"bottom\"`. */\n  paperAnchorBottom: {\n    top: 'auto',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 'auto',\n    maxHeight: '100%'\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"left\"` and `variant` is not \"temporary\". */\n  paperAnchorDockedLeft: {\n    borderRight: `1px solid ${theme.palette.divider}`\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"top\"` and `variant` is not \"temporary\". */\n  paperAnchorDockedTop: {\n    borderBottom: `1px solid ${theme.palette.divider}`\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"right\"` and `variant` is not \"temporary\". */\n  paperAnchorDockedRight: {\n    borderLeft: `1px solid ${theme.palette.divider}`\n  },\n\n  /* Styles applied to the `Paper` component if `anchor=\"bottom\"` and `variant` is not \"temporary\". */\n  paperAnchorDockedBottom: {\n    borderTop: `1px solid ${theme.palette.divider}`\n  },\n\n  /* Styles applied to the `Modal` component. */\n  modal: {}\n});\nconst oppositeDirection = {\n  left: 'right',\n  right: 'left',\n  top: 'down',\n  bottom: 'up'\n};\nexport function isHorizontal(anchor) {\n  return ['left', 'right'].indexOf(anchor) !== -1;\n}\nexport function getAnchor(theme, anchor) {\n  return theme.direction === 'rtl' && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;\n}\nconst defaultTransitionDuration = {\n  enter: duration.enteringScreen,\n  exit: duration.leavingScreen\n};\n/**\n * The props of the [Modal](/api/modal/) component are available\n * when `variant=\"temporary\"` is set.\n */\n\nconst Drawer = /*#__PURE__*/React.forwardRef(function Drawer(props, ref) {\n  const {\n    anchor: anchorProp = 'left',\n    BackdropProps,\n    children,\n    classes,\n    className,\n    elevation = 16,\n    ModalProps: {\n      BackdropProps: BackdropPropsProp\n    } = {},\n    onClose,\n    open = false,\n    PaperProps = {},\n    SlideProps,\n    // eslint-disable-next-line react/prop-types\n    TransitionComponent = Slide,\n    transitionDuration = defaultTransitionDuration,\n    variant = 'temporary'\n  } = props,\n        ModalProps = _objectWithoutProperties(props.ModalProps, [\"BackdropProps\"]),\n        other = _objectWithoutProperties(props, [\"anchor\", \"BackdropProps\", \"children\", \"classes\", \"className\", \"elevation\", \"ModalProps\", \"onClose\", \"open\", \"PaperProps\", \"SlideProps\", \"TransitionComponent\", \"transitionDuration\", \"variant\"]);\n\n  const theme = useTheme(); // Let's assume that the Drawer will always be rendered on user space.\n  // We use this state is order to skip the appear transition during the\n  // initial mount of the component.\n\n  const mounted = React.useRef(false);\n  React.useEffect(() => {\n    mounted.current = true;\n  }, []);\n  const anchor = getAnchor(theme, anchorProp);\n\n  const drawer = __jsx(Paper, _extends({\n    elevation: variant === 'temporary' ? elevation : 0,\n    square: true\n  }, PaperProps, {\n    className: clsx(classes.paper, classes[`paperAnchor${capitalize(anchor)}`], PaperProps.className, variant !== 'temporary' && classes[`paperAnchorDocked${capitalize(anchor)}`])\n  }), children);\n\n  if (variant === 'permanent') {\n    return __jsx(\"div\", _extends({\n      className: clsx(classes.root, classes.docked, className),\n      ref: ref\n    }, other), drawer);\n  }\n\n  const slidingDrawer = __jsx(TransitionComponent, _extends({\n    in: open,\n    direction: oppositeDirection[anchor],\n    timeout: transitionDuration,\n    appear: mounted.current\n  }, SlideProps), drawer);\n\n  if (variant === 'persistent') {\n    return __jsx(\"div\", _extends({\n      className: clsx(classes.root, classes.docked, className),\n      ref: ref\n    }, other), slidingDrawer);\n  } // variant === temporary\n\n\n  return __jsx(Modal, _extends({\n    BackdropProps: _objectSpread(_objectSpread(_objectSpread({}, BackdropProps), BackdropPropsProp), {}, {\n      transitionDuration\n    }),\n    BackdropComponent: Backdrop,\n    className: clsx(classes.root, classes.modal, className),\n    open: open,\n    onClose: onClose,\n    ref: ref\n  }, other, ModalProps), slidingDrawer);\n});\nexport default withStyles(styles, {\n  name: 'MuiDrawer',\n  flip: false\n})(Drawer);","map":null,"metadata":{},"sourceType":"module"}